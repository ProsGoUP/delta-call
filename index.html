<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î”Call - ×©×™×—×ª ×•×™×“××• | Phase Network</title>
    <!-- PeerJS - Public Signaling Server (NO PORT FORWARD NEEDED!) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --delta-cyan: #00d4ff;
            --delta-green: #00ff88;
            --delta-purple: #9d4edd;
            --delta-pink: #ff006e;
            --bg-dark: #0a0a1a;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Header */
        .header {
            text-align: center;
            padding: 40px 0;
        }
        
        .logo {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, var(--delta-cyan), var(--delta-green), var(--delta-pink));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
        }
        
        .protocol-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,212,255,0.1);
            border: 1px solid var(--delta-cyan);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 15px;
            font-size: 12px;
            color: var(--delta-cyan);
        }
        
        /* Call Card */
        .call-card {
            background: rgba(255,255,255,0.05);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            border: 1px solid rgba(0,212,255,0.2);
            margin-bottom: 30px;
        }
        
        .caller-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--delta-cyan), var(--delta-green));
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            font-size: 48px;
            font-weight: bold;
            color: #000;
            box-shadow: 0 0 40px rgba(0,212,255,0.3);
        }
        
        .caller-name {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .caller-id {
            font-family: monospace;
            color: var(--delta-cyan);
            font-size: 14px;
            background: rgba(0,212,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
        }
        
        .call-status {
            color: var(--delta-green);
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        .call-status.ringing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Buttons */
        .buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 16px 40px;
            border-radius: 50px;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn-answer {
            background: linear-gradient(90deg, var(--delta-green), var(--delta-cyan));
            color: #000;
        }
        
        .btn-answer:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.5);
        }
        
        .btn-decline {
            background: rgba(255,68,68,0.2);
            color: #ff4444;
            border: 2px solid #ff4444;
        }
        
        .btn-decline:hover {
            background: #ff4444;
            color: white;
        }
        
        .btn-call {
            background: linear-gradient(90deg, var(--delta-cyan), var(--delta-green));
            color: #000;
        }
        
        .btn-call:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,212,255,0.5);
        }
        
        /* Input */
        .input-section {
            background: rgba(255,255,255,0.05);
            border-radius: 24px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .input-section h3 {
            margin-bottom: 20px;
            color: var(--delta-cyan);
        }
        
        .input-group {
            display: flex;
            gap: 10px;
        }
        
        .input-group input {
            flex: 1;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 16px;
        }
        
        .input-group input::placeholder {
            color: #666;
        }
        
        /* Video Container */
        .video-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1000;
        }
        
        .video-container.active {
            display: block;
        }
        
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #111;
        }
        
        .local-video {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 150px;
            height: 200px;
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid var(--delta-cyan);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .local-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .video-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn.end-call {
            background: #ff4444;
            color: white;
        }
        
        .control-btn.mute {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
        }
        
        /* Stats - Î”Protocol Stats */
        .call-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 12px;
            border: 1px solid rgba(0,212,255,0.3);
        }
        
        .stats-header {
            color: var(--delta-cyan);
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #888;
        }
        
        .stat-value {
            color: var(--delta-green);
            font-family: monospace;
        }
        
        .stat-value.phase {
            color: var(--delta-purple);
        }
        
        /* Features - Î”Protocol Features */
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .feature {
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .feature-icon {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .feature-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .feature-desc {
            color: #888;
            font-size: 11px;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status.connected {
            background: rgba(0,255,136,0.2);
            color: var(--delta-green);
            border: 1px solid var(--delta-green);
        }
        
        .connection-status.disconnected {
            background: rgba(255,68,68,0.2);
            color: #ff4444;
            border: 1px solid #ff4444;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: blink 2s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Phase Visualization */
        .phase-visualizer {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--delta-purple);
        }
        
        .phase-wave {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 30px;
        }
        
        .phase-bar {
            width: 4px;
            background: var(--delta-purple);
            border-radius: 2px;
            animation: wave 0.5s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { height: 10px; }
            50% { height: 25px; }
        }
        
        /* Î”Packet Log */
        .packet-log {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            border: 1px solid rgba(0,212,255,0.2);
        }
        
        .packet-log-header {
            color: var(--delta-cyan);
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .packet-entry {
            color: #888;
            margin-bottom: 4px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.02);
            border-radius: 4px;
        }
        
        .packet-entry.tx {
            border-left: 2px solid var(--delta-green);
        }
        
        .packet-entry.rx {
            border-left: 2px solid var(--delta-purple);
        }
    </style>
</head>
<body>
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">
        <span class="status-dot"></span>
        <span id="statusText">××ª×—×‘×¨ ×œ×¨×©×ª Î”...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">Î”Call</div>
            <div class="subtitle">×©×™×—×•×ª ×•×™×“××• ×¢×œ Phase Network</div>
            <div class="protocol-badge">
                <span>âš¡</span>
                <span>Î”Protocol v1.0 | 0-Data | Phase Resonance</span>
            </div>
        </div>
        
        <!-- Call Input -->
        <div class="input-section" id="callInput">
            <h3>ğŸ“ ×”×ª×§×©×¨ ×“×¨×š Î”Network</h3>
            <div class="input-group">
                <input type="text" id="targetDeltaId" placeholder="×”×›× ×¡ Î”ID ×©×œ ××™ ×©×¨×•×¦×™× ×œ×”×ª×§×©×¨...">
                <button class="btn btn-call" onclick="startCall()">
                    ğŸ“ Î”Call
                </button>
            </div>
        </div>
        
        <!-- Incoming Call Card -->
        <div class="call-card" id="incomingCall" style="display: none;">
            <div class="caller-avatar" id="callerAvatar">?</div>
            <div class="caller-name" id="callerName">××™×©×”×• ××ª×§×©×¨...</div>
            <div class="caller-id" id="callerId">Î”-unknown</div>
            <div class="call-status ringing">ğŸ”” ×©×™×—×” × ×›× ×¡×ª ×“×¨×š Phase Network...</div>
            <div class="buttons">
                <button class="btn btn-answer" onclick="answerCall()">
                    ğŸ“ ×¢× ×”
                </button>
                <button class="btn btn-decline" onclick="declineCall()">
                    âŒ ×“×—×”
                </button>
            </div>
        </div>
        
        <!-- My ID Card -->
        <div class="call-card">
            <h3 style="margin-bottom: 20px;">ğŸ†” ×”-Î”ID ×©×œ×™</h3>
            <div class="caller-id" id="myDeltaId" style="cursor: pointer;" onclick="copyMyId()">
                ×˜×•×¢×Ÿ...
            </div>
            <p style="color: #888; font-size: 14px; margin-top: 15px;">
                ×œ×—×¥ ×œ×”×¢×ª×§×” | ×©×ª×£ ××ª ×”-ID ×”×–×” ×›×“×™ ×©×™×•×›×œ×• ×œ×”×ª×§×©×¨ ××œ×™×š
            </p>
            
            <!-- Î”Packet Log -->
            <div class="packet-log" id="packetLog">
                <div class="packet-log-header">ğŸ“¦ Î”Packet Log</div>
                <div id="packetEntries"></div>
            </div>
        </div>
        
        <!-- Î”Protocol Features -->
        <div class="features">
            <div class="feature">
                <div class="feature-icon">âš¡</div>
                <div class="feature-title">Î”Packet</div>
                <div class="feature-desc">×ª×§×©×•×¨×ª ××•× ×™×‘×¨×¡×œ×™×ª</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸŒŠ</div>
                <div class="feature-title">Phase Sync</div>
                <div class="feature-desc">×¡× ×›×¨×•×Ÿ ×˜××¤×•×¨×œ×™</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ”®</div>
                <div class="feature-title">0-Data</div>
                <div class="feature-desc">8 bits ×œ×¤×¨×™×™×</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ”’</div>
                <div class="feature-title">Î”-Signed</div>
                <div class="feature-desc">×—×ª×™××” ×§×¨×™×¤×˜×•×’×¨×¤×™×ª</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ’</div>
                <div class="feature-title">Î”J Energy</div>
                <div class="feature-desc">×¢×œ×•×ª ×× ×¨×’×™×”</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸŒ</div>
                <div class="feature-title">Mesh Network</div>
                <div class="feature-desc">×¨×©×ª ××‘×•×–×¨×ª</div>
            </div>
        </div>
    </div>
    
    <!-- Video Call Container -->
    <div class="video-container" id="videoContainer">
        <video class="remote-video" id="remoteVideo" autoplay playsinline></video>
        <div class="local-video">
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
        
        <!-- Î”Protocol Stats -->
        <div class="call-stats">
            <div class="stats-header">
                <span>âš¡</span> Î”Protocol Stats
            </div>
            <div class="stat-row">
                <span class="stat-label">Î”t:</span>
                <span class="stat-value" id="callDuration">00:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Phase:</span>
                <span class="stat-value phase" id="currentPhase">0Â°</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Î”J:</span>
                <span class="stat-value" id="energyUsed">0.00 J</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Packets TX:</span>
                <span class="stat-value" id="packetsTx">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Packets RX:</span>
                <span class="stat-value" id="packetsRx">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Bits/Frame:</span>
                <span class="stat-value" id="bitsPerFrame">8</span>
            </div>
        </div>
        
        <!-- Phase Visualizer -->
        <div class="phase-visualizer">
            <div style="color: #9d4edd; font-size: 11px; margin-bottom: 8px;">Phase Wave</div>
            <div class="phase-wave" id="phaseWave">
                <!-- Generated dynamically -->
            </div>
        </div>
        
        <div class="video-controls">
            <button class="control-btn mute" id="muteBtn" onclick="toggleMute()">ğŸ¤</button>
            <button class="control-btn end-call" onclick="endCall()">ğŸ“´</button>
            <button class="control-btn mute" id="videoBtn" onclick="toggleVideo()">ğŸ“¹</button>
        </div>
    </div>

    <script>
        // ğŸ”¥ğŸ’âš¡ Î”Call Web Client - Using Î”Protocol âš¡ğŸ’ğŸ”¥
        // ================================================
        
        // ğŸ”¥ Î”NET - Dynamic Connection to ANY Gateway!
        // The page connects to wherever it was loaded from - no hardcoded addresses!
        // This enables our mesh network - any user with internet is a gateway!
        const isSecure = window.location.protocol === 'https:';
        const currentHost = window.location.host; // Gets host:port dynamically
        
        // ğŸ”¥ğŸ’âš¡ Î”CLOUD SIGNALING - OUR OWN SERVER! âš¡ğŸ’ğŸ”¥
        // If we're on GitHub Pages or other static host, use our IPv6 server!
        const isStaticHost = currentHost.includes('github.io') || 
                            currentHost.includes('netlify') ||
                            currentHost.includes('vercel');
        
        // Our Î”CLOUD server - accessible via IPv6 from anywhere!
        const DELTA_CLOUD_IPV6 = '2a0d:6fc2:41c9:b100:b999:bc7f:9c65:38';
        const DELTA_CLOUD_PORT = 8081;
        const DELTA_CLOUD_URL = `http://[${DELTA_CLOUD_IPV6}]:${DELTA_CLOUD_PORT}`;
        const DELTA_CLOUD_WS = `ws://[${DELTA_CLOUD_IPV6}]:${DELTA_CLOUD_PORT}`;
        
        // ğŸ”¥ HTTPS pages can't connect to HTTP/WS servers (Mixed Content)!
        // If we're on HTTPS static host, use PeerJS only (no WebSocket to our server)
        const canUseWebSocket = !isSecure || !isStaticHost;
        
        // Use local server if available, otherwise use Î”CLOUD
        const SERVER_URL = isStaticHost ? DELTA_CLOUD_URL : `${window.location.protocol}//${currentHost}`;
        const WS_URL = isStaticHost ? DELTA_CLOUD_WS : `${isSecure ? 'wss:' : 'ws:'}//${currentHost}`;
        
        console.log('ğŸ”¥ Î”NET Gateway:', SERVER_URL);
        console.log('ğŸ”Œ WebSocket Gateway:', WS_URL);
        console.log('â˜ï¸ Î”CLOUD Mode:', isStaticHost ? 'YES (using IPv6)' : 'NO (local server)');
        console.log('ğŸ”’ HTTPS Mode:', isSecure ? 'YES (PeerJS only)' : 'NO (WebSocket available)');
        
        // Î”Protocol State
        let myDeltaId = null;
        let currentCallId = null;
        let webSocket = null;
        let localStream = null;
        let callStartTime = null;
        let callTimer = null;
        
        // ğŸ”¥ PeerJS - Public Signaling (NO PORT FORWARD NEEDED!)
        let peer = null;
        let peerCall = null;
        let peerDataConnection = null;  // ğŸ”¥ For Phase Resonance data!
        let dataConnectionReady = false;  // ğŸ”¥ Flag to track if DataConnection is ready
        let usingPeerJSStream = false;  // ğŸ”¥ Flag to track if using PeerJS video stream
        
        // ============================================================
        // ğŸŒŒ Î”PHASE0 - THE PRIME PHASE (Shared Reality)
        // ============================================================
        // The ONE truth that all phases synchronize to:
        // - Time (absolute)
        // - Sequence (order of events)
        // - Delta (changes)
        // - Identity (who did what)
        
        class Î”PHASE0 {
            static instance = null;
            
            constructor() {
                if (Î”PHASE0.instance) return Î”PHASE0.instance;
                
                this.phaseValue = 0.0;
                this.frequency = 500.0;  // Hz - base frequency
                // ğŸ”¥ğŸ’âš¡ CRITICAL: Use UNIX EPOCH (0) as shared reference!
                // This way ALL browsers calculate the SAME phase!
                // Î”PHASE0 = shared physics = UNIX TIME!
                this.epoch = 0;  // â† NOT Date.now()! Everyone shares UNIX time!
                this.sequenceCounter = 0;
                this.connectedPhases = new Map();
                
                // Global state
                this.globalDelta = 0.0;
                this.globalEnergy = 0.0;
                
                Î”PHASE0.instance = this;
                console.log('ğŸŒŒ Î”PHASE0 (Prime Phase) initialized - UNIX EPOCH shared!');
            }
            
            getAbsoluteTime() {
                return Date.now();
            }
            
            getSequence() {
                this.sequenceCounter++;
                return this.sequenceCounter;
            }
            
            getPhase() {
                // ğŸ”¥ Everyone on Earth calculates the SAME phase!
                // Phase = (UNIX_TIME_SECONDS * 500Hz) mod 1.0
                const unixSeconds = Date.now() / 1000;
                this.phaseValue = (unixSeconds * this.frequency) % 1.0;
                return this.phaseValue;
            }
            
            registerPhase(phase) {
                this.connectedPhases.set(phase.phaseId, phase);
                console.log(`ğŸ“¡ Phase registered with Î”PHASE0: ${phase.phaseId}`);
            }
            
            unregisterPhase(phaseId) {
                if (this.connectedPhases.has(phaseId)) {
                    this.connectedPhases.delete(phaseId);
                    console.log(`ğŸ“´ Phase unregistered: ${phaseId}`);
                }
            }
        }
        
        // ============================================================
        // ğŸ”® Î”Phase - Individual Personal Phase
        // ============================================================
        // Each human/machine has one - contains your context, intention,
        // perception, and private meaning
        
        class Î”Phase {
            constructor(phaseId, ownerName) {
                this.phaseId = phaseId || `phase_${Date.now().toString(36)}`;
                this.ownerName = ownerName || 'Unknown';
                this.context = {};
                this.intention = '';
                this.perception = {};
                this.privateMeaning = {};
                
                // Phase state
                this.localPhase = 0.0;
                this.localFrequency = 500.0;
                this.drift = 0.0;
                
                // Connection state
                this.isConnected = false;
                this.lastSync = 0;
                
                console.log(`ğŸ”® Î”Phase created: ${this.phaseId} (${this.ownerName})`);
            }
            
            updateContext(key, value) {
                this.context[key] = value;
            }
            
            setIntention(intention) {
                this.intention = intention;
            }
            
            perceive(event) {
                const eventId = event.id || Date.now().toString();
                this.perception[eventId] = {
                    event: event,
                    perceivedAt: Date.now(),
                    localPhase: this.localPhase
                };
            }
            
            deriveMeaning(eventId, meaning) {
                this.privateMeaning[eventId] = meaning;
            }
        }
        
        // ============================================================
        // ğŸ”¥ Î”PHASE-GATEWAY - THE PRESSURE CELL
        // ============================================================
        // The controlled environment where private phases meet Î”PHASE0
        // Functions: normalize, compress, map intent, safety check, align, translate
        
        class PhaseGateway {
            constructor(gatewayId) {
                this.gatewayId = gatewayId || `gateway_${Date.now()}`;
                this.primePhase = new Î”PHASE0();
                
                this.phases = new Map();
                this.pressure = 1.0;
                this.isOpen = true;
                
                this.stats = {
                    phasesNormalized: 0,
                    deltasCompressed: 0,
                    intentsMapped: 0,
                    safetyChecks: 0,
                    alignments: 0,
                    translations: 0,
                    totalDataSaved: 0
                };
                
                this.externalEndpoints = [];
                
                console.log(`ğŸ”¥ Î”PHASE-GATEWAY initialized: ${this.gatewayId}`);
            }
            
            // 1. Phase Normalization
            normalizePhase(phase) {
                const primePhase = this.primePhase.getPhase();
                const primeTime = this.primePhase.getAbsoluteTime();
                
                const drift = phase.localPhase - primePhase;
                
                const normalized = {
                    phaseId: phase.phaseId,
                    originalPhase: phase.localPhase,
                    normalizedPhase: primePhase,
                    drift: drift,
                    correction: -drift,
                    primeTime: primeTime,
                    sequence: this.primePhase.getSequence()
                };
                
                phase.localPhase = primePhase;
                phase.drift = drift;
                phase.lastSync = primeTime;
                
                this.stats.phasesNormalized++;
                return normalized;
            }
            
            // 2. Delta Compression
            compressDelta(data, previous = null) {
                if (!previous) {
                    return { type: 'full', data: data, size: JSON.stringify(data).length };
                }
                
                const changes = [];
                for (const key in data) {
                    if (data[key] !== previous[key]) {
                        changes.push({ key, old: previous[key], new: data[key] });
                    }
                }
                
                const originalSize = JSON.stringify(data).length;
                const compressedSize = JSON.stringify(changes).length;
                this.stats.totalDataSaved += Math.max(0, originalSize - compressedSize);
                this.stats.deltasCompressed++;
                
                return { type: 'delta', changes, originalSize, compressedSize };
            }
            
            // 3. Intent â†’ Meaning Mapping
            mapIntentToMeaning(phase, intent) {
                const intentLower = intent.toLowerCase();
                const actionMap = {
                    'call': 'communication',
                    'pay': 'transaction',
                    'send': 'transfer',
                    'share': 'broadcast',
                    'find': 'discovery',
                    'connect': 'link'
                };
                
                let category = 'general';
                for (const [keyword, cat] of Object.entries(actionMap)) {
                    if (intentLower.includes(keyword)) {
                        category = cat;
                        break;
                    }
                }
                
                this.stats.intentsMapped++;
                
                return {
                    originalIntent: intent,
                    category: category,
                    phaseId: phase.phaseId,
                    timestamp: this.primePhase.getAbsoluteTime(),
                    sequence: this.primePhase.getSequence(),
                    canExecute: true
                };
            }
            
            // 4. Safety Check
            safetyCheck(phase, action) {
                const checks = {
                    phaseNormalized: Math.abs(phase.drift) < 0.01,
                    phaseConnected: phase.isConnected,
                    actionValid: action.category !== undefined,
                    noConflicts: true,
                    resourcesAvailable: true
                };
                
                const passed = Object.values(checks).every(v => v);
                this.stats.safetyChecks++;
                
                return { passed, checks, phaseId: phase.phaseId };
            }
            
            // 5. Cross-Phase Alignment
            alignPhases(phaseIds) {
                const phases = phaseIds.map(id => this.phases.get(id)).filter(p => p);
                if (phases.length < 2) return { success: false, reason: 'Need at least 2 phases' };
                
                const referencePhase = this.primePhase.getPhase();
                const referenceTime = this.primePhase.getAbsoluteTime();
                
                const alignments = phases.map(phase => {
                    const oldPhase = phase.localPhase;
                    phase.localPhase = referencePhase;
                    phase.lastSync = referenceTime;
                    return { phaseId: phase.phaseId, oldPhase, newPhase: referencePhase };
                });
                
                this.stats.alignments++;
                return { success: true, alignedCount: phases.length, referencePhase, alignments };
            }
            
            // 6. Translate Semantics
            translateSemantics(sourcePhase, targetPhase, message) {
                this.stats.translations++;
                return {
                    original: message,
                    sourcePhase: sourcePhase.phaseId,
                    targetPhase: targetPhase.phaseId,
                    translationTime: this.primePhase.getAbsoluteTime(),
                    content: message
                };
            }
            
            // Connect/Disconnect phases
            connectPhase(phase) {
                this.normalizePhase(phase);
                this.primePhase.registerPhase(phase);
                this.phases.set(phase.phaseId, phase);
                phase.isConnected = true;
                console.log(`âœ… Phase connected to gateway: ${phase.phaseId}`);
                return true;
            }
            
            disconnectPhase(phaseId) {
                if (!this.phases.has(phaseId)) return false;
                const phase = this.phases.get(phaseId);
                phase.isConnected = false;
                this.primePhase.unregisterPhase(phaseId);
                this.phases.delete(phaseId);
                return true;
            }
            
            addExternalEndpoint(endpoint) {
                if (!this.externalEndpoints.includes(endpoint)) {
                    this.externalEndpoints.push(endpoint);
                    console.log(`ğŸŒ External endpoint added: ${endpoint}`);
                }
            }
            
            getStats() {
                return {
                    gatewayId: this.gatewayId,
                    connectedPhases: this.phases.size,
                    externalEndpoints: this.externalEndpoints.length,
                    ...this.stats
                };
            }
        }
        
        // ============================================================
        // ğŸŒ GLOBAL GATEWAY - OUR OWN CLOUDFLARE REPLACEMENT!
        // ============================================================
        // Any user with internet becomes a gateway for others!
        
        class GatewayNode {
            constructor(nodeId, publicEndpoint, capabilities = []) {
                this.nodeId = nodeId;
                this.publicEndpoint = publicEndpoint;
                this.capabilities = capabilities;
                this.bandwidthMbps = 100.0;
                this.latencyMs = 5.0;
                this.isOnline = true;
                this.lastSeen = Date.now();
                this.connectedUsers = 0;
            }
        }
        
        class GatewayRegistry {
            constructor() {
                this.gateways = new Map();
                this.primaryGateway = null;
                console.log('ğŸŒ Gateway Registry initialized');
            }
            
            registerGateway(gateway) {
                this.gateways.set(gateway.nodeId, gateway);
                if (!this.primaryGateway || gateway.latencyMs < this.gateways.get(this.primaryGateway).latencyMs) {
                    this.primaryGateway = gateway.nodeId;
                }
                console.log(`âœ… Gateway registered: ${gateway.nodeId} at ${gateway.publicEndpoint}`);
                return true;
            }
            
            unregisterGateway(nodeId) {
                if (this.gateways.has(nodeId)) {
                    this.gateways.delete(nodeId);
                    if (this.primaryGateway === nodeId) {
                        this.primaryGateway = this.findBestGateway();
                    }
                    return true;
                }
                return false;
            }
            
            getBestGateway() {
                if (this.primaryGateway && this.gateways.has(this.primaryGateway)) {
                    return this.gateways.get(this.primaryGateway);
                }
                const bestId = this.findBestGateway();
                return bestId ? this.gateways.get(bestId) : null;
            }
            
            findBestGateway() {
                let best = null;
                let bestLatency = Infinity;
                for (const [id, gw] of this.gateways) {
                    if (gw.isOnline && gw.latencyMs < bestLatency) {
                        best = id;
                        bestLatency = gw.latencyMs;
                    }
                }
                return best;
            }
            
            getAllEndpoints() {
                return Array.from(this.gateways.values())
                    .filter(gw => gw.isOnline)
                    .map(gw => gw.publicEndpoint);
            }
        }
        
        class GlobalGateway {
            constructor(config = {}) {
                this.nodeId = config.nodeId || `gw_${Date.now().toString(36)}`;
                this.registry = new GatewayRegistry();
                
                this.isGateway = false;
                this.publicEndpoint = null;
                this.connectedUsers = new Set();
                
                this.stats = {
                    requestsRouted: 0,
                    bytesTransferred: 0,
                    gatewaySwitches: 0,
                    meshFallbacks: 0
                };
                
                console.log(`ğŸ”¥ Î”GLOBAL GATEWAY initialized: ${this.nodeId}`);
            }
            
            enableGatewayMode(publicEndpoint = null) {
                this.publicEndpoint = publicEndpoint || `${window.location.origin}`;
                this.isGateway = true;
                
                const gatewayNode = new GatewayNode(
                    this.nodeId,
                    this.publicEndpoint,
                    ['routing', 'video_call', 'data_sync']
                );
                
                this.registry.registerGateway(gatewayNode);
                
                console.log('ğŸŒ Gateway mode enabled!');
                console.log(`   Public endpoint: ${this.publicEndpoint}`);
                return true;
            }
            
            disableGatewayMode() {
                if (!this.isGateway) return false;
                this.registry.unregisterGateway(this.nodeId);
                this.isGateway = false;
                this.publicEndpoint = null;
                return true;
            }
            
            addExternalGateway(endpoint, nodeId = null) {
                const id = nodeId || `ext_${Date.now().toString(36)}`;
                const gatewayNode = new GatewayNode(id, endpoint, ['routing', 'video_call']);
                gatewayNode.latencyMs = 50.0; // Estimate for external
                this.registry.registerGateway(gatewayNode);
                return true;
            }
            
            getConnectionUrl() {
                if (this.isGateway && this.publicEndpoint) return this.publicEndpoint;
                const best = this.registry.getBestGateway();
                return best ? best.publicEndpoint : window.location.origin;
            }
            
            getShareableLink(path = '/call') {
                return `${this.getConnectionUrl()}${path}`;
            }
            
            routeRequest(request) {
                const gateway = this.registry.getBestGateway();
                if (gateway) {
                    this.stats.requestsRouted++;
                    return { success: true, gateway: gateway.nodeId, endpoint: gateway.publicEndpoint, latencyMs: gateway.latencyMs };
                }
                this.stats.meshFallbacks++;
                return { success: true, gateway: 'mesh', endpoint: 'mesh://local', latencyMs: 5.0 };
            }
            
            connectUser(userId) {
                this.connectedUsers.add(userId);
                if (this.registry.gateways.has(this.nodeId)) {
                    this.registry.gateways.get(this.nodeId).connectedUsers = this.connectedUsers.size;
                }
                return true;
            }
            
            disconnectUser(userId) {
                this.connectedUsers.delete(userId);
                return true;
            }
            
            getStats() {
                return {
                    nodeId: this.nodeId,
                    isGateway: this.isGateway,
                    publicEndpoint: this.publicEndpoint,
                    connectedUsers: this.connectedUsers.size,
                    registeredGateways: this.registry.gateways.size,
                    allEndpoints: this.registry.getAllEndpoints(),
                    ...this.stats
                };
            }
        }
        
        // ============================================================
        // ğŸ“¡ NODE DISCOVERY - Discover nearby nodes (BLE, WiFi, NFC)
        // ============================================================
        
        const DiscoveryMethod = {
            BLUETOOTH: 'bluetooth',
            WIFI_DIRECT: 'wifi_direct',
            NFC: 'nfc',
            CELLULAR: 'cellular',
            INTERNET: 'internet'
        };
        
        class NodeDiscovery {
            constructor(config = {}) {
                this.nodeId = config.nodeId || `node_${Date.now().toString(36)}`;
                this.scanInterval = config.scanInterval || 5.0;
                this.maxConnections = config.maxConnections || 20;
                
                this.discoveredNodes = new Map();
                this.activeConnections = new Map();
                this.advertisements = [];
                
                this.stats = {
                    scansPerformed: 0,
                    nodesDiscovered: 0,
                    connectionsEstablished: 0,
                    connectionsLost: 0
                };
                
                console.log(`ğŸ“¡ Node Discovery initialized: ${this.nodeId}`);
            }
            
            async scanProximity(methods = [DiscoveryMethod.BLUETOOTH, DiscoveryMethod.WIFI_DIRECT]) {
                const discovered = [];
                
                for (const method of methods) {
                    const nodes = await this.scanWithMethod(method);
                    discovered.push(...nodes);
                }
                
                for (const node of discovered) {
                    if (!this.discoveredNodes.has(node.nodeId)) {
                        this.stats.nodesDiscovered++;
                    }
                    this.discoveredNodes.set(node.nodeId, {
                        ...node,
                        lastSeen: Date.now(),
                        discoveryMethod: node.method
                    });
                }
                
                this.stats.scansPerformed++;
                console.log(`âš¡ Scan complete: ${discovered.length} nodes found`);
                return discovered;
            }
            
            async scanWithMethod(method) {
                // In real implementation: use Web Bluetooth API, WiFi Direct, etc.
                // Simulated discovery for demo
                const numNodes = Math.floor(Math.random() * 3) + 1;
                const discovered = [];
                
                for (let i = 0; i < numNodes; i++) {
                    discovered.push({
                        nodeId: `${method}_${i}_${Date.now().toString(36)}`,
                        method: method,
                        signalStrength: 0.5 + Math.random() * 0.5,
                        distanceM: Math.random() * 100
                    });
                }
                
                return discovered;
            }
            
            advertiseSelf() {
                const ad = {
                    nodeId: this.nodeId,
                    capabilities: ['routing', 'payment', 'storage', 'compute'],
                    frequency: 1000.0,
                    timestamp: Date.now()
                };
                
                this.advertisements.push(ad);
                if (this.advertisements.length > 100) {
                    this.advertisements = this.advertisements.slice(-100);
                }
                
                return ad;
            }
            
            connectToNode(nodeId, method = null) {
                if (!this.discoveredNodes.has(nodeId)) {
                    console.warn(`âš ï¸ Node ${nodeId} not discovered`);
                    return null;
                }
                
                if (this.activeConnections.size >= this.maxConnections) {
                    console.warn(`âš ï¸ Max connections reached (${this.maxConnections})`);
                    return null;
                }
                
                const nodeInfo = this.discoveredNodes.get(nodeId);
                const connection = {
                    nodeId: nodeId,
                    method: method || nodeInfo.discoveryMethod,
                    signalStrength: 0.7 + Math.random() * 0.3,
                    latencyMs: 1 + Math.random() * 9,
                    bandwidthMbps: 1 + Math.random() * 99,
                    establishedAt: Date.now()
                };
                
                this.activeConnections.set(nodeId, connection);
                this.stats.connectionsEstablished++;
                console.log(`âœ… Connected to ${nodeId} via ${connection.method}`);
                
                return connection;
            }
            
            getStats() {
                return {
                    ...this.stats,
                    discoveredNodes: this.discoveredNodes.size,
                    activeConnections: this.activeConnections.size
                };
            }
        }
        
        // ============================================================
        // ğŸ”„ GATEWAY SWITCH - Switch between networks intelligently
        // ============================================================
        
        const NetworkType = {
            MESH: 'mesh',
            INTERNET: 'internet',
            CELLULAR: 'cellular',
            WIFI: 'wifi',
            BLUETOOTH: 'bluetooth'
        };
        
        class GatewaySwitch {
            constructor(config = {}) {
                this.nodeId = config.nodeId || `switch_${Date.now().toString(36)}`;
                this.preferMesh = config.preferMesh !== false;
                this.maxCostPerMb = config.maxCostPerMb || 0.01;
                
                this.availableNetworks = new Map();
                this.activeNetwork = null;
                this.networkHistory = [];
                
                this.stats = {
                    networkSwitches: 0,
                    totalDataMb: 0.0,
                    totalCost: 0.0,
                    avgLatencyMs: 0.0
                };
                
                console.log(`ğŸ”„ Gateway Switch initialized: ${this.nodeId}`);
            }
            
            detectNetworks() {
                const detected = [];
                
                // Mesh network (always available if neighbors exist)
                const mesh = {
                    networkId: 'mesh_local',
                    networkType: NetworkType.MESH,
                    bandwidthMbps: 10.0,
                    latencyMs: 5.0,
                    costPerMb: 0.0,  // Free!
                    reliability: 0.9,
                    isAvailable: true
                };
                detected.push(mesh);
                this.availableNetworks.set(mesh.networkId, mesh);
                
                // WiFi (simulate)
                if (Math.random() > 0.3) {
                    const wifi = {
                        networkId: 'wifi_home',
                        networkType: NetworkType.WIFI,
                        bandwidthMbps: 100.0,
                        latencyMs: 10.0,
                        costPerMb: 0.0,
                        reliability: 0.95,
                        isAvailable: true
                    };
                    detected.push(wifi);
                    this.availableNetworks.set(wifi.networkId, wifi);
                }
                
                // Cellular
                const cellular = {
                    networkId: 'cellular_5g',
                    networkType: NetworkType.CELLULAR,
                    bandwidthMbps: 50.0,
                    latencyMs: 20.0,
                    costPerMb: 0.005,
                    reliability: 0.98,
                    isAvailable: true
                };
                detected.push(cellular);
                this.availableNetworks.set(cellular.networkId, cellular);
                
                console.log(`ğŸ“¡ Detected ${detected.length} networks`);
                return detected;
            }
            
            switchNetwork(networkId) {
                if (!this.availableNetworks.has(networkId)) {
                    console.warn(`âš ï¸ Network ${networkId} not available`);
                    return false;
                }
                
                const network = this.availableNetworks.get(networkId);
                if (!network.isAvailable) return false;
                
                const oldNetwork = this.activeNetwork;
                this.activeNetwork = network;
                this.networkHistory.push(networkId);
                if (this.networkHistory.length > 100) {
                    this.networkHistory = this.networkHistory.slice(-100);
                }
                
                this.stats.networkSwitches++;
                console.log(`ğŸ”„ Switched: ${oldNetwork?.networkId || 'none'} â†’ ${networkId}`);
                return true;
            }
            
            loadBalance(networks) {
                if (!networks.length) return {};
                
                const scores = {};
                for (const network of networks) {
                    const score = (
                        network.bandwidthMbps * 0.3 +
                        (100 - network.latencyMs) * 0.2 +
                        (1 - network.costPerMb * 100) * 0.2 +
                        network.reliability * 100 * 0.3
                    );
                    scores[network.networkId] = Math.max(0, score);
                }
                
                const total = Object.values(scores).reduce((a, b) => a + b, 0);
                if (total === 0) return {};
                
                const distribution = {};
                for (const [id, score] of Object.entries(scores)) {
                    distribution[id] = score / total;
                }
                
                return distribution;
            }
            
            fallbackNetwork() {
                const preferenceOrder = [NetworkType.MESH, NetworkType.WIFI, NetworkType.CELLULAR, NetworkType.BLUETOOTH];
                
                for (const netType of preferenceOrder) {
                    for (const network of this.availableNetworks.values()) {
                        if (network.networkType === netType && network.isAvailable) {
                            console.log(`ğŸ”™ Fallback: ${network.networkId}`);
                            return network;
                        }
                    }
                }
                
                return null;
            }
            
            getStats() {
                return {
                    ...this.stats,
                    availableNetworks: this.availableNetworks.size,
                    activeNetwork: this.activeNetwork?.networkId || null
                };
            }
        }
        
        // ============================================================
        // ğŸ•¸ï¸ MESH ROUTER - Route through human mesh network
        // ============================================================
        
        const RouteQuality = {
            EXCELLENT: 'excellent',
            GOOD: 'good',
            FAIR: 'fair',
            POOR: 'poor'
        };
        
        class MeshRouter {
            constructor(config = {}) {
                this.nodeId = config.nodeId || `router_${Date.now().toString(36)}`;
                this.maxHops = config.maxHops || 10;
                this.routeCacheTtl = config.routeCacheTtl || 60.0;
                
                this.neighbors = new Map();
                this.routingTable = new Map();
                this.routeCache = new Map();
                this.packetQueue = new Map();
                
                this.stats = {
                    packetsRouted: 0,
                    routesDiscovered: 0,
                    routingFailures: 0,
                    averageHops: 0.0,
                    totalEnergyUsed: 0.0
                };
                
                console.log(`ğŸ•¸ï¸ Mesh Router initialized: ${this.nodeId}`);
            }
            
            discoverNeighbors(scanRadius = 100.0) {
                const discovered = [];
                const numNeighbors = Math.floor(Math.random() * 4) + 2;
                
                for (let i = 0; i < numNeighbors; i++) {
                    const node = {
                        nodeId: `node_${i}_${Date.now().toString(36)}`,
                        location: [
                            (Math.random() - 0.5) * scanRadius * 2,
                            (Math.random() - 0.5) * scanRadius * 2,
                            0
                        ],
                        frequency: 1000 + (Math.random() - 0.5) * 200,
                        lastSeen: Date.now(),
                        hopCount: 1,
                        energyCost: 0.01 + Math.random() * 0.09
                    };
                    
                    this.neighbors.set(node.nodeId, node);
                    discovered.push(node);
                }
                
                console.log(`âš¡ Discovered ${discovered.length} neighbors within ${scanRadius}m`);
                return discovered;
            }
            
            routePhase(phase, destination) {
                const cacheKey = `${this.nodeId}_${destination}`;
                
                if (this.routeCache.has(cacheKey)) {
                    const cached = this.routeCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < this.routeCacheTtl * 1000) {
                        return cached.route;
                    }
                }
                
                const route = this.findRoute(destination);
                
                if (route) {
                    this.routeCache.set(cacheKey, { route, timestamp: Date.now() });
                    this.routingTable.set(destination, route);
                    this.stats.routesDiscovered++;
                    this.stats.averageHops = (
                        (this.stats.averageHops * (this.stats.routesDiscovered - 1) + route.hops.length) /
                        this.stats.routesDiscovered
                    );
                    console.log(`ğŸ¯ Route found: ${route.hops.length} hops, ${route.latencyMs.toFixed(1)}ms`);
                } else {
                    this.stats.routingFailures++;
                    console.warn(`âš ï¸ No route found to ${destination}`);
                }
                
                return route;
            }
            
            findRoute(destination) {
                // Simple BFS
                const visited = new Set([this.nodeId]);
                const queue = [[this.nodeId, [this.nodeId]]];
                
                while (queue.length > 0) {
                    const [current, path] = queue.shift();
                    
                    if (current === destination) {
                        return {
                            routeId: `route_${Date.now().toString(36)}`,
                            source: this.nodeId,
                            destination: destination,
                            hops: path,
                            totalDistance: path.length * 50,
                            totalEnergy: path.length * 0.05,
                            quality: this.assessRouteQuality(path),
                            latencyMs: path.length * 2
                        };
                    }
                    
                    if (path.length >= this.maxHops) continue;
                    
                    for (const neighborId of this.neighbors.keys()) {
                        if (!visited.has(neighborId)) {
                            visited.add(neighborId);
                            queue.push([neighborId, [...path, neighborId]]);
                        }
                    }
                }
                
                return null;
            }
            
            forwardPacket(source, destination, data) {
                if (!this.packetQueue.has(destination)) {
                    this.packetQueue.set(destination, []);
                }
                
                this.packetQueue.get(destination).push({
                    source,
                    data,
                    timestamp: Date.now()
                });
                
                this.stats.packetsRouted++;
                console.log(`âœ… Packet queued for ${destination}`);
                return true;
            }
            
            getPacketForNode(nodeId) {
                if (this.packetQueue.has(nodeId) && this.packetQueue.get(nodeId).length > 0) {
                    const packet = this.packetQueue.get(nodeId).shift();
                    console.log(`âœ… Retrieved packet for ${nodeId}`);
                    return packet;
                }
                return null;
            }
            
            assessRouteQuality(hops) {
                const hopCount = hops.length;
                if (hopCount <= 3) return RouteQuality.EXCELLENT;
                if (hopCount <= 5) return RouteQuality.GOOD;
                if (hopCount <= 7) return RouteQuality.FAIR;
                return RouteQuality.POOR;
            }
            
            getStats() {
                return {
                    ...this.stats,
                    neighborCount: this.neighbors.size,
                    routingTableSize: this.routingTable.size,
                    cacheSize: this.routeCache.size
                };
            }
        }
        
        // ============================================================
        // ğŸŒ‰ Î”BRIDGE - Gateway between Î”Worlds and regular Internet
        // ============================================================
        
        class Î”Bridge {
            constructor(config = {}) {
                this.nodeId = config.nodeId || `bridge_${Date.now().toString(36)}`;
                this.maxRequestSize = config.maxRequestSize || 10 * 1024 * 1024;
                this.timeoutSeconds = config.timeoutSeconds || 30.0;
                this.cacheEnabled = config.cacheEnabled !== false;
                this.cacheTtl = config.cacheTtl || 300;
                
                this.cache = new Map();
                this.cacheHits = 0;
                this.cacheMisses = 0;
                
                this.stats = {
                    requestsTotal: 0,
                    requestsSuccess: 0,
                    requestsFailed: 0,
                    bytesDownloaded: 0,
                    bytesUploaded: 0,
                    avgLatencyMs: 0.0,
                    uniqueOrigins: new Set(),
                    uniqueDomains: new Set()
                };
                
                console.log(`ğŸŒ‰ Î”BRIDGE initialized: ${this.nodeId}`);
            }
            
            async proxy(request) {
                this.stats.requestsTotal++;
                this.stats.uniqueOrigins.add(request.origin);
                
                if (!this.validateRequest(request)) {
                    return this.errorResponse(request.requestId, 400, 'Invalid request');
                }
                
                // Check cache for GET
                if (request.method === 'GET' && this.cacheEnabled) {
                    const cached = this.getFromCache(request.url);
                    if (cached) {
                        this.cacheHits++;
                        return cached;
                    }
                    this.cacheMisses++;
                }
                
                try {
                    const startTime = Date.now();
                    const response = await fetch(request.url, {
                        method: request.method,
                        headers: request.headers,
                        body: request.body
                    });
                    
                    const body = await response.text();
                    const latencyMs = Date.now() - startTime;
                    
                    const bridgeResponse = {
                        requestId: request.requestId,
                        statusCode: response.status,
                        headers: Object.fromEntries(response.headers.entries()),
                        body: body,
                        contentType: response.headers.get('content-type') || 'text/plain',
                        sizeBytes: body.length,
                        latencyMs: latencyMs,
                        cached: false,
                        timestamp: Date.now()
                    };
                    
                    this.stats.requestsSuccess++;
                    this.stats.bytesDownloaded += body.length;
                    this.stats.avgLatencyMs = (
                        (this.stats.avgLatencyMs * (this.stats.requestsSuccess - 1) + latencyMs) /
                        this.stats.requestsSuccess
                    );
                    
                    // Track domain
                    try {
                        const url = new URL(request.url);
                        this.stats.uniqueDomains.add(url.hostname);
                    } catch (e) {}
                    
                    // Cache GET responses
                    if (request.method === 'GET' && this.cacheEnabled) {
                        this.setInCache(request.url, bridgeResponse);
                    }
                    
                    console.log(`âœ… Proxied: ${request.method} ${request.url.substring(0, 50)}... â†’ ${response.status}`);
                    return bridgeResponse;
                    
                } catch (error) {
                    this.stats.requestsFailed++;
                    console.error(`âŒ Proxy error: ${error.message}`);
                    return this.errorResponse(request.requestId, 502, error.message);
                }
            }
            
            validateRequest(request) {
                if (!request.url) return false;
                try {
                    const url = new URL(request.url);
                    if (!['http:', 'https:'].includes(url.protocol)) return false;
                } catch (e) {
                    return false;
                }
                if (!request.origin || request.origin === 'unknown') return false;
                return true;
            }
            
            getFromCache(url) {
                const key = `GET:${url}`;
                if (this.cache.has(key)) {
                    const { response, timestamp } = this.cache.get(key);
                    if (Date.now() - timestamp < this.cacheTtl * 1000) {
                        response.cached = true;
                        return response;
                    }
                    this.cache.delete(key);
                }
                return null;
            }
            
            setInCache(url, response) {
                const key = `GET:${url}`;
                this.cache.set(key, { response: { ...response }, timestamp: Date.now() });
            }
            
            errorResponse(requestId, statusCode, message) {
                return {
                    requestId,
                    statusCode,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ error: message }),
                    contentType: 'application/json',
                    sizeBytes: message.length,
                    latencyMs: 0,
                    cached: false,
                    timestamp: Date.now()
                };
            }
            
            getStats() {
                return {
                    bridgeId: this.nodeId,
                    requests: {
                        total: this.stats.requestsTotal,
                        success: this.stats.requestsSuccess,
                        failed: this.stats.requestsFailed,
                        successRate: this.stats.requestsTotal > 0 ? this.stats.requestsSuccess / this.stats.requestsTotal : 0
                    },
                    data: {
                        downloadedBytes: this.stats.bytesDownloaded,
                        downloadedMb: this.stats.bytesDownloaded / (1024 * 1024)
                    },
                    performance: {
                        avgLatencyMs: this.stats.avgLatencyMs
                    },
                    unique: {
                        origins: this.stats.uniqueOrigins.size,
                        domains: this.stats.uniqueDomains.size
                    },
                    cache: {
                        size: this.cache.size,
                        hits: this.cacheHits,
                        misses: this.cacheMisses,
                        hitRate: (this.cacheHits + this.cacheMisses) > 0 ? this.cacheHits / (this.cacheHits + this.cacheMisses) : 0
                    }
                };
            }
        }
        
        // ============================================================
        // ğŸ”¥ GLOBAL INSTANCES
        // ============================================================
        
        let primePhase = null;       // Î”PHASE0 singleton
        let myPhase = null;          // My personal Î”Phase
        let phaseGateway = null;     // PhaseGateway instance
        let globalGateway = null;    // GlobalGateway instance
        let nodeDiscovery = null;    // NodeDiscovery instance
        let gatewaySwitch = null;    // GatewaySwitch instance
        let meshRouter = null;       // MeshRouter instance
        let deltaBridge = null;      // Î”Bridge instance
        
        // ============================================================
        // ğŸ”¥ğŸ’âš¡ Î”STATION - COMPLETE NODE FOR EACH USER âš¡ğŸ’ğŸ”¥
        // ============================================================
        // Each user is a full station that RECEIVES and SENDS!
        // Based on: PhaseGateway, MeshRouter, SyncLoop, TemporalResonance
        class Î”Station {
            constructor(stationId) {
                this.stationId = stationId;
                this.phase = 0.0;
                this.frequency = 500.0;  // Base frequency Hz
                // ğŸ”¥ğŸ’âš¡ Use UNIX EPOCH for global synchronization!
                this.epoch = 0;  // â† Everyone shares UNIX time!
                this.isConnected = false;
                this.lastSync = 0;
                this.drift = 0;
                
                // Connected peers (other stations)
                this.peers = new Map();  // peerId -> peerPhase
                
                // Packet queues
                this.outgoingQueue = [];
                this.incomingQueue = [];
                
                // Stats
                this.stats = {
                    packetsSent: 0,
                    packetsReceived: 0,
                    syncCount: 0,
                    resonanceQuality: 0
                };
                
                console.log(`ğŸ”¥ Î”Station created: ${stationId} - UNIX EPOCH sync!`);
            }
            
            // Get current phase (oscillates at frequency) - GLOBAL SYNC!
            getPhase() {
                // ğŸ”¥ Everyone calculates the SAME phase from UNIX time!
                const unixSeconds = Date.now() / 1000;
                this.phase = (unixSeconds * this.frequency) % 1.0;
                return this.phase;
            }
            
            // Register a peer station
            registerPeer(peerId, peerPhase = 0) {
                this.peers.set(peerId, {
                    phase: peerPhase,
                    lastSeen: Date.now(),
                    drift: 0
                });
                console.log(`ğŸ“¡ Peer registered: ${peerId}`);
            }
            
            // Sync with peer - align phases
            syncWithPeer(peerId, peerPhase, peerTime) {
                const myPhase = this.getPhase();
                const now = Date.now();
                
                // Calculate drift
                const drift = myPhase - peerPhase;
                this.drift = drift;
                
                // Calculate latency
                const latency = (now - peerTime) / 2;
                
                // Update peer info
                if (this.peers.has(peerId)) {
                    const peer = this.peers.get(peerId);
                    peer.phase = peerPhase;
                    peer.lastSeen = now;
                    peer.drift = drift;
                }
                
                // Calculate resonance quality
                const resonance = this.calculateResonance(this.frequency, this.frequency);
                this.stats.resonanceQuality = resonance;
                this.stats.syncCount++;
                this.lastSync = now;
                
                console.log(`ğŸ”„ Synced with ${peerId}: drift=${drift.toFixed(6)}, latency=${latency.toFixed(0)}ms, resonance=${resonance.toFixed(3)}`);
                
                return { drift, latency, resonance };
            }
            
            // Calculate resonance between two frequencies
            calculateResonance(freq1, freq2) {
                if (freq1 === 0 || freq2 === 0) return 0;
                const ratio = Math.max(freq1, freq2) / Math.min(freq1, freq2);
                const nearestInteger = Math.round(ratio);
                const deviation = Math.abs(ratio - nearestInteger);
                return Math.exp(-deviation / 0.05);
            }
            
            // Queue packet for sending
            queueOutgoing(peerId, data) {
                this.outgoingQueue.push({
                    to: peerId,
                    data: data,
                    phase: this.getPhase(),
                    timestamp: Date.now()
                });
                this.stats.packetsSent++;
            }
            
            // Receive packet
            receivePacket(fromId, data) {
                this.incomingQueue.push({
                    from: fromId,
                    data: data,
                    receivedAt: Date.now()
                });
                this.stats.packetsReceived++;
                
                // Sync with sender's phase if available
                if (data.phase !== undefined && data.timestamp) {
                    this.syncWithPeer(fromId, data.phase, data.timestamp);
                }
            }
            
            // Get next outgoing packet
            getNextOutgoing() {
                return this.outgoingQueue.shift();
            }
            
            // Get next incoming packet
            getNextIncoming() {
                return this.incomingQueue.shift();
            }
            
            getStats() {
                return {
                    ...this.stats,
                    phase: this.getPhase(),
                    frequency: this.frequency,
                    drift: this.drift,
                    peerCount: this.peers.size,
                    isConnected: this.isConnected
                };
            }
        }
        
        // ğŸ”¥ Create station for this user
        let myStation = null;
        const PEERJS_CONFIG = {
            // Use public PeerJS cloud server - FREE and always accessible!
            host: '0.peerjs.com',
            port: 443,
            secure: true,
            debug: 2,  // ğŸ”¥ More debug info for troubleshooting
            config: {
                iceServers: [
                    // STUN servers (for direct P2P when possible)
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    // ğŸ”¥ FREE TURN servers that WORK! (Metered.ca free tier)
                    { 
                        urls: 'turn:a.relay.metered.ca:80',
                        username: 'e8dd65b92f6067e7e3c7c5e5',
                        credential: 'uWdWNmkhvyqTmFLo'
                    },
                    { 
                        urls: 'turn:a.relay.metered.ca:80?transport=tcp',
                        username: 'e8dd65b92f6067e7e3c7c5e5',
                        credential: 'uWdWNmkhvyqTmFLo'
                    },
                    { 
                        urls: 'turn:a.relay.metered.ca:443',
                        username: 'e8dd65b92f6067e7e3c7c5e5',
                        credential: 'uWdWNmkhvyqTmFLo'
                    },
                    { 
                        urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                        username: 'e8dd65b92f6067e7e3c7c5e5',
                        credential: 'uWdWNmkhvyqTmFLo'
                    }
                ],
                iceCandidatePoolSize: 10
            }
        };
        
        // ğŸ”¥ WebRTC for real video/audio
        let peerConnection = null;
        const rtcConfig = {
            iceServers: [
                // STUN - for direct P2P (when possible)
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // ğŸ”¥ FREE TURN servers that WORK! (Metered.ca free tier)
                { 
                    urls: 'turn:a.relay.metered.ca:80',
                    username: 'e8dd65b92f6067e7e3c7c5e5',
                    credential: 'uWdWNmkhvyqTmFLo'
                },
                { 
                    urls: 'turn:a.relay.metered.ca:80?transport=tcp',
                    username: 'e8dd65b92f6067e7e3c7c5e5',
                    credential: 'uWdWNmkhvyqTmFLo'
                },
                { 
                    urls: 'turn:a.relay.metered.ca:443',
                    username: 'e8dd65b92f6067e7e3c7c5e5',
                    credential: 'uWdWNmkhvyqTmFLo'
                },
                { 
                    urls: 'turn:a.relay.metered.ca:443?transport=tcp',
                    username: 'e8dd65b92f6067e7e3c7c5e5',
                    credential: 'uWdWNmkhvyqTmFLo'
                }
            ],
            iceCandidatePoolSize: 10
        };
        
        // Î”Protocol Stats
        let packetsTx = 0;
        let packetsRx = 0;
        let totalEnergy = 0;
        let currentPhase = 0;
        
        // ========================================
        // Î”Packet - Universal Communication Unit
        // ========================================
        
        class Î”Packet {
            constructor(context, metadata = {}) {
                this.Î”t = Date.now() / 1000;  // Unix timestamp
                this.Î”J = this.calculateEnergy(context);  // Energy cost
                this.origin = myDeltaId;
                this.context = context;
                this.signature = this.sign();
                this.merkleProof = null;
                this.metadata = metadata;
            }
            
            calculateEnergy(context) {
                // Energy cost based on context
                const costs = {
                    'videoPhase': 0.001,  // 1mJ per video phase
                    'audioPhase': 0.0005, // 0.5mJ per audio phase
                    'call_start': 0.01,   // 10mJ to start call
                    'call_end': 0.005,    // 5mJ to end call
                    'sync': 0.0001        // 0.1mJ for sync
                };
                return costs[context] || 0.001;
            }
            
            sign() {
                // Simple signature (in production: use proper crypto)
                const data = `${this.Î”t}|${this.origin}|${this.context}`;
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash).toString(16).padStart(16, '0');
            }
            
            toJSON() {
                return {
                    Î”t: this.Î”t,
                    Î”J: this.Î”J,
                    origin: this.origin,
                    context: this.context,
                    signature: this.signature,
                    merkleProof: this.merkleProof,
                    metadata: this.metadata
                };
            }
        }
        
        // ========================================
        // Phase Engine - 0-Data Video Processing
        // ========================================
        
        class PhaseEngine {
            constructor() {
                this.lastFrame = null;
                this.phaseHistory = [];
            }
            
            // Generate 8-bit phase signature from video frame
            generatePhaseSignature(imageData) {
                if (!this.lastFrame) {
                    this.lastFrame = imageData;
                    return 0;
                }
                
                // Calculate change between frames
                let totalChange = 0;
                const data = imageData.data;
                const lastData = this.lastFrame.data;
                
                // Sample every 100th pixel for efficiency
                for (let i = 0; i < data.length; i += 400) {
                    const diff = Math.abs(data[i] - lastData[i]);
                    totalChange += diff;
                }
                
                this.lastFrame = imageData;
                
                // Normalize to 8 bits (0-255)
                const phase = Math.min(255, Math.floor(totalChange / 1000));
                this.phaseHistory.push(phase);
                
                // Keep only last 100 phases
                if (this.phaseHistory.length > 100) {
                    this.phaseHistory.shift();
                }
                
                return phase;
            }
            
            // Reconstruct from phase (receiver side)
            reconstructFromPhase(phase, context) {
                // In real implementation: use context + phase to reconstruct
                // For demo: return color based on phase
                return {
                    intensity: phase,
                    confidence: 0.95
                };
            }
        }
        
        const phaseEngine = new PhaseEngine();
        
        // ========================================
        // Î”FieldBus - Local Event Broadcasting
        // ========================================
        
        class Î”FieldBus {
            constructor() {
                this.subscribers = new Map();
            }
            
            subscribe(context, callback) {
                if (!this.subscribers.has(context)) {
                    this.subscribers.set(context, []);
                }
                this.subscribers.get(context).push(callback);
            }
            
            publish(packet) {
                const callbacks = this.subscribers.get(packet.context) || [];
                callbacks.forEach(cb => cb(packet));
                
                // Also publish to 'all' subscribers
                const allCallbacks = this.subscribers.get('all') || [];
                allCallbacks.forEach(cb => cb(packet));
            }
        }
        
        const fieldBus = new Î”FieldBus();
        
        // ========================================
        // PeerJS - Public Signaling (NO PORT FORWARD!)
        // ========================================
        
        function initPeerJS() {
            // Create peer with our Delta ID (cleaned for PeerJS)
            // PeerJS IDs must start with letter and contain only alphanumeric + hyphen
            let peerId = myDeltaId.replace(/[^a-zA-Z0-9]/g, '');
            // Ensure it starts with a letter
            if (!/^[a-zA-Z]/.test(peerId)) {
                peerId = 'D' + peerId;
            }
            
            console.log('ğŸ”¥ Initializing PeerJS with ID:', peerId);
            
            console.log('ğŸ”¥ğŸ”¥ğŸ”¥ Initializing PeerJS...');
            console.log('   Config:', JSON.stringify(PEERJS_CONFIG));
            
            peer = new Peer(peerId, PEERJS_CONFIG);
            
            peer.on('open', (id) => {
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ âœ… PEERJS CONNECTED TO SIGNALING SERVER! â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('   My PeerJS ID:', id);
                updateStatus('××—×•×‘×¨ ×œ×¨×©×ª Î” (P2P)', 'connected');
                
                // Show shareable link
                const shareLink = `${window.location.origin}/call?call=${myDeltaId}`;
                console.log('ğŸ“± Share this link:', shareLink);
            });
            
            peer.on('call', async (call) => {
                console.log('ğŸ“ Incoming P2P call from:', call.peer);
                
                // Show incoming call UI
                showIncomingCall(call.peer);
                
                // Store the call for answering
                window.pendingPeerCall = call;
            });
            
            // ğŸ”¥ Listen for data connections (Phase Resonance!)
            peer.on('connection', (conn) => {
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ ğŸ”¥ğŸ”¥ğŸ”¥ INCOMING DATA CONNECTION! ğŸ”¥ğŸ”¥ğŸ”¥   â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('   From peer:', conn.peer);
                console.log('   conn.open:', conn.open);
                console.log('   conn.reliable:', conn.reliable);
                console.log('   conn.serialization:', conn.serialization);
                console.log('   conn.type:', conn.type);
                peerDataConnection = conn;
                
                conn.on('data', (data) => {
                    // ğŸ”¥ Log first few packets
                    if (packetsRx < 5) {
                        console.log('ğŸ“¥ ANSWERER RECEIVED PACKET #' + (packetsRx + 1) + ':', data.type);
                    }
                    
                    // Handle Phase Resonance data!
                    if (data.type === 'phase_sync') {
                        // ğŸ”¥ PHASE SYNC: Sync our time to caller's time!
                        handlePhaseSync(data);
                    } else if (data.type === 'phase') {
                        handlePhaseData(data);
                    } else if (data.type === 'video_frame') {
                        handleVideoFrame(data);
                    } else if (data.type === 'audio') {
                        handleAudioFrame(data);
                    } else if (data.type === 'audio_phase') {
                        handleAudioPhase(data);
                    }
                    packetsRx++;
                    updateStats();
                });
                
                // ğŸ”¥ FIX: Check if already open OR wait for open event!
                // In PeerJS, connection might already be open when received!
                function startAnswererResonance() {
                    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                    console.log('â•‘ âœ… ANSWERER: DataConnection OPEN!        â•‘');
                    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('   Setting dataConnectionReady = true');
                    console.log('   usingPeerJSStream:', usingPeerJSStream);
                    console.log('   localStream:', !!localStream);
                    console.log('   currentCallId:', currentCallId);
                    dataConnectionReady = true;
                    
                    // ğŸ”¥ğŸ’âš¡ CREATE ANSWERER'S CALL PRESSURE CELL! âš¡ğŸ’ğŸ”¥
                    // The answerer also creates a pressure cell, which will be
                    // synchronized to the caller's epoch when phase_sync arrives!
                    const callerPeerId = conn.peer;
                    if (!callPressureCell) {
                        createCallPressureCell(currentCallId || 'answerer-call', callerPeerId, myDeltaId);
                        console.log('ğŸ”¥ Answerer created Call Pressure Cell!');
                    }
                    
                    // ğŸ”¥ Show visual indicator that Phase Resonance is ready!
                    updateStatus('ğŸ”¥ × ×›× ×¡ ×œ×ª× ×œ×—×¥ ××©×•×ª×£!', 'connected');
                    
                    // ğŸ”¥ Generate callId if not set yet (DataConnection can arrive before answer!)
                    if (!currentCallId) {
                        currentCallId = 'p2p-answerer-' + Date.now();
                        console.log('ğŸ“ Generated answerer callId:', currentCallId);
                    }
                    // ğŸ”¥ DON'T override usingPeerJSStream here!
                    // If PeerJS media stream is active, keep using it
                    // DataConnection is for Phase Resonance DATA, not video!
                    console.log('ğŸ“¡ DataConnection ready, usingPeerJSStream:', usingPeerJSStream);
                    
                    // ğŸ”¥ CRITICAL: Only setup resonance if we have localStream!
                    // DataConnection can arrive BEFORE user clicks "Answer"!
                    if (localStream) {
                        setupResonanceSync();
                    } else {
                        console.log('â³ Waiting for localStream before starting resonance...');
                        // Will be started when answerPeerCall() is called
                    }
                }
                
                // ğŸ”¥ Handle connection close
                conn.on('close', () => {
                    console.log('âš ï¸ DataConnection closed!');
                    dataConnectionReady = false;
                    peerDataConnection = null;
                });
                
                // ğŸ”¥ Handle connection error
                conn.on('error', (err) => {
                    console.error('âŒ DataConnection error:', err);
                    dataConnectionReady = false;
                });
                
                if (conn.open) {
                    // Already open - start immediately!
                    startAnswererResonance();
                } else {
                    // Wait for open event
                    conn.on('open', startAnswererResonance);
                }
            });
            
            peer.on('error', (err) => {
                console.error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.error('â•‘ âŒ PEERJS ERROR!                         â•‘');
                console.error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.error('   Error type:', err.type);
                console.error('   Error message:', err.message || err);
                
                // ğŸ”¥ Handle peer-unavailable - target peer doesn't exist!
                if (err.type === 'peer-unavailable') {
                    console.error('âŒ TARGET PEER NOT FOUND!');
                    alert('âŒ ×”×¦×“ ×”×©× ×™ ×œ× × ××¦×!\n\n×•×•×“× ×©:\n1. ×”×¦×“ ×”×©× ×™ ×¤×ª×•×— ×•××—×•×‘×¨\n2. ×”×¢×ª×§×ª ××ª ×”-ID ×”× ×›×•×Ÿ\n3. ×”×¦×“ ×”×©× ×™ ×œ× ×¨×¢× ×Ÿ ××ª ×”×“×£');
                    updateStatus('âŒ ×”×¦×“ ×”×©× ×™ ×œ× × ××¦×', 'error');
                    return;
                }
                
                // ğŸ”¥ If ID is taken, generate a NEW unique ID and retry!
                if (err.type === 'unavailable-id') {
                    console.log('ğŸ”„ ID is taken - generating new unique ID...');
                    const timestamp = Date.now().toString(36);
                    const random = Math.random().toString(36).substr(2, 8);
                    myDeltaId = `Î”-web-${timestamp}-${random}`;
                    localStorage.setItem('delta_id', myDeltaId);
                    document.getElementById('myDeltaId').textContent = myDeltaId;
                    
                    if (peer) {
                        peer.destroy();
                    }
                    
                    setTimeout(() => {
                        console.log('ğŸ”„ Retrying with new ID:', myDeltaId);
                        initPeerJS();
                    }, 500);
                    return;
                }
                
                // Fallback to WebSocket if PeerJS fails for other reasons
                if (!webSocket || webSocket.readyState !== WebSocket.OPEN) {
                    connectWebSocket();
                }
            });
            
            peer.on('disconnected', () => {
                console.log('âš ï¸ PeerJS disconnected, reconnecting...');
                peer.reconnect();
            });
        }
        
        async function answerPeerCall() {
            if (!window.pendingPeerCall) {
                console.error('âŒ No pending call to answer!');
                return;
            }
            
            const call = window.pendingPeerCall;
            console.log('ğŸ“ Answering P2P call from:', call.peer);
            
            // ğŸ”¥ Check if mediaDevices is available (requires HTTPS or localhost)
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('âŒ mediaDevices not available - need HTTPS!');
                alert('âš ï¸ × ×“×¨×© HTTPS ×œ×’×™×©×” ×œ××¦×œ××”!\n\n×”×©×ª××© ×‘:\nâ€¢ https://prosgoup.github.io/delta-call/\nâ€¢ ××• localhost');
                return;
            }
            
            // ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE - NOT WebRTC! âš¡ğŸ’ğŸ”¥
            // We use Phase Resonance for video - 8 bits instead of megabits!
            usingPeerJSStream = false;
            console.log('ğŸ”¥ Phase Resonance mode (ANSWERER) - 0-Data!');
            
            // Get local media
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                console.log('ğŸ“¹ Local stream ready:', localStream.getTracks().map(t => t.kind + ':' + t.enabled));
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ Show video container IMMEDIATELY for answerer!
                document.getElementById('videoContainer').classList.add('active');
                document.getElementById('incomingCall').style.display = 'none';
                document.getElementById('callInput').style.display = 'none';
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE - NO WebRTC MEDIA STREAM! âš¡ğŸ’ğŸ”¥
                // We DON'T use call.on('stream') - that's the OLD way!
                // Remote video comes from Phase Resonance reconstruction!
                
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE - 0-DATA VIDEO! âš¡ğŸ’ğŸ”¥              â•‘');
                console.log('â•‘ NOT using WebRTC media stream - using Phase sync instead!       â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // We still need to "answer" the call to complete PeerJS handshake
                // But we won't use the media stream - only DataConnection!
                call.answer(localStream);  // Complete handshake
                
                peerCall = call;
                window.pendingPeerCall = null;
                currentCallId = 'phase-' + Date.now();
                
                console.log('âœ… Call answered! Using Phase Resonance for video (8 bits!)');
                
                // ğŸ”¥ Start Phase Resonance video reconstruction immediately!
                startVideoReconstruction();
                
                // ğŸ”¥ ALWAYS start resonance sync for answerer!
                console.log('ğŸ”¥ ANSWERER: dataConnectionReady=', dataConnectionReady, 'peerDataConnection=', !!peerDataConnection);
                if (dataConnectionReady && peerDataConnection) {
                    console.log('ğŸ”¥ DataConnection already ready - starting resonance now!');
                    setupResonanceSync();
                } else {
                    // ğŸ”¥ Wait a bit and try again - connection might be arriving!
                    console.log('â³ Waiting for DataConnection...');
                    const waitForConnection = setInterval(() => {
                        if (dataConnectionReady && peerDataConnection) {
                            console.log('ğŸ”¥ DataConnection arrived! Starting resonance!');
                            clearInterval(waitForConnection);
                            setupResonanceSync();
                        }
                    }, 100);
                    // Timeout after 10 seconds
                    setTimeout(() => clearInterval(waitForConnection), 10000);
                }
                
            } catch (err) {
                console.error('âŒ Media error:', err);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”/××™×§×¨×•×¤×•×Ÿ');
                usingPeerJSStream = false;
            }
        }
        
        async function startPeerCall(targetId) {
            // Clean target ID for PeerJS - must start with letter
            let peerId = targetId.replace(/[^a-zA-Z0-9]/g, '');
            if (!/^[a-zA-Z]/.test(peerId)) {
                peerId = 'D' + peerId;
            }
            
            console.log('ğŸ“ Starting P2P call to:', peerId);
            
            // ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE - NOT WebRTC! âš¡ğŸ’ğŸ”¥
            // We DON'T send video data - we send PHASE only (8 bits!)
            // The other side reconstructs video from phase resonance!
            usingPeerJSStream = false;  // â† Phase Resonance mode (0-Data!)
            
            // ğŸ”¥ Check if mediaDevices is available (requires HTTPS or localhost)
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('âŒ mediaDevices not available - need HTTPS!');
                alert('âš ï¸ × ×“×¨×© HTTPS ×œ×’×™×©×” ×œ××¦×œ××”!\n\n×”×©×ª××© ×‘:\nâ€¢ https://prosgoup.github.io/delta-call/\nâ€¢ ××• localhost');
                return;
            }
            
            try {
                // Get local media
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ Show video container IMMEDIATELY for caller!
                document.getElementById('videoContainer').classList.add('active');
                document.getElementById('callInput').style.display = 'none';
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // ğŸ”¥ Show waiting message on remote video
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.poster = '';
                remoteVideo.style.background = '#111';
                
                // ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE âš¡ğŸ’ğŸ”¥
                // We use peer.call() to trigger peer.on('call') on the other side
                // But we DON'T use the WebRTC stream - we use Phase Resonance!
                
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ ğŸ”¥ğŸ’âš¡ PHASE RESONANCE MODE - 0-DATA VIDEO! âš¡ğŸ’ğŸ”¥              â•‘');
                console.log('â•‘ Using peer.call() for signaling, Phase Resonance for video!     â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                currentCallId = 'phase-' + Date.now();
                
                // ğŸ”¥ Call the peer to trigger their peer.on('call') handler
                // This is just for SIGNALING - we won't use the WebRTC stream!
                console.log('ğŸ“ Calling peer for signaling:', peerId);
                const call = peer.call(peerId, localStream);
                
                if (!call) {
                    console.error('âŒ Failed to create call!');
                    alert('×œ× ×”×¦×œ×—×ª×™ ×œ×”×ª×—×‘×¨ - ×•×•×“× ×©×”-ID × ×›×•×Ÿ');
                    return;
                }
                
                peerCall = call;
                
                // ğŸ”¥ We DON'T listen to call.on('stream') - we use Phase Resonance instead!
                call.on('error', (err) => {
                    console.error('âŒ Call signaling error:', err);
                    // Don't show alert - Phase Resonance will still work via DataConnection!
                });
                
                call.on('close', () => {
                    console.log('ğŸ“´ Call signaling closed');
                });
                
                // ğŸ”¥ Open DataConnection for Phase Resonance!
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ ğŸ”¥ CALLER: Opening Phase Resonance!      â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('   Target peer:', peerId);
                peerDataConnection = peer.connect(peerId, { 
                    reliable: true,
                    serialization: 'binary'  // ğŸ”¥ Binary for JPEG frames!
                });
                
                console.log('   peerDataConnection created:', !!peerDataConnection);
                console.log('   peerDataConnection.open:', peerDataConnection.open);
                
                // ğŸ”¥ Add timeout for connection!
                let connectionTimeout = setTimeout(() => {
                    if (!dataConnectionReady) {
                        console.error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                        console.error('â•‘ âŒ CONNECTION TIMEOUT (10 seconds)!      â•‘');
                        console.error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                        console.error('   Possible causes:');
                        console.error('   1. Target peer is not connected');
                        console.error('   2. Target peer ID is wrong');
                        console.error('   3. Network/firewall blocking');
                        updateStatus('âŒ ×œ× ×”×¦×œ×—×ª×™ ×œ×”×ª×—×‘×¨ - × ×¡×” ×©×•×‘', 'error');
                        alert('âŒ ×œ× ×”×¦×œ×—×ª×™ ×œ×”×ª×—×‘×¨!\n\n×•×•×“× ×©:\n1. ×”×¦×“ ×”×©× ×™ ×¤×ª×•×— ×•××—×•×‘×¨\n2. ×”×¢×ª×§×ª ××ª ×”-ID ×”× ×›×•×Ÿ\n3. ×©× ×™ ×”×¦×“×“×™× ××¨××™× "PEERJS CONNECTED"');
                    }
                }, 10000);
                
                peerDataConnection.on('open', () => {
                    clearTimeout(connectionTimeout);  // ğŸ”¥ Cancel timeout!
                    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                    console.log('â•‘ âœ… CALLER: DataConnection OPEN!          â•‘');
                    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.log('   dataConnectionReady = true');
                    dataConnectionReady = true;  // ğŸ”¥ Mark as ready!
                    
                    // ğŸ”¥ Show visual indicator that Phase Resonance is ready!
                    updateStatus('ğŸ”¥ Phase Resonance ××—×•×‘×¨!', 'connected');
                    
                    // ğŸ”¥ğŸ’âš¡ CREATE CALL PRESSURE CELL! âš¡ğŸ’ğŸ”¥
                    // This creates a shared Î”PHASE0 for the call!
                    const remotePeerId = peerDataConnection.peer;
                    createCallPressureCell(currentCallId, myDeltaId, remotePeerId);
                    
                    // ğŸ”¥ PHASE SYNC: Send our callStartTime AND callEpoch to peer!
                    // This puts BOTH sides in the SAME PRESSURE CELL!
                    peerDataConnection.send({
                        type: 'phase_sync',
                        callStartTime: callStartTime,
                        phaseOrigin: Date.now(),
                        callEpoch: callPressureCell.getCallEpoch(),  // ğŸ”¥ NEW!
                        callId: currentCallId,
                        callerId: myDeltaId
                    });
                    console.log('ğŸ“¡ Sent phase_sync with CALL PRESSURE CELL epoch:', callPressureCell.getCallEpoch());
                    
                    // ğŸ”¥ Start Phase Resonance video reconstruction!
                    startVideoReconstruction();
                    
                    // ğŸ”¥ Start Phase Resonance transmission!
                    setupResonanceSync();
                });
                
                peerDataConnection.on('error', (err) => {
                    console.error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                    console.error('â•‘ âŒ DataConnection ERROR!                 â•‘');
                    console.error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                    console.error('   Error:', err);
                    console.error('   Target peer:', peerId);
                    console.error('   This usually means the peer is not connected!');
                    dataConnectionReady = false;
                    updateStatus('âŒ ×©×’×™××ª ×—×™×‘×•×¨', 'error');
                });
                
                peerDataConnection.on('close', () => {
                    console.log('âš ï¸ CALLER: DataConnection closed!');
                    dataConnectionReady = false;
                    peerDataConnection = null;
                });
                
                peerDataConnection.on('data', (data) => {
                    // ğŸ”¥ Log first few packets
                    if (packetsRx < 5) {
                        console.log('ğŸ“¥ CALLER RECEIVED PACKET #' + (packetsRx + 1) + ':', data.type);
                    }
                    
                    // Handle Phase Resonance data from peer!
                    if (data.type === 'phase_sync') {
                        // ğŸ”¥ PHASE SYNC: Sync our time to caller's time!
                        handlePhaseSync(data);
                    } else if (data.type === 'video_frame') {
                        handleVideoFrame(data);
                    } else if (data.type === 'audio') {
                        handleAudioFrame(data);
                    } else if (data.type === 'audio_phase') {
                        handleAudioPhase(data);
                    } else if (data.type === 'phase') {
                        handlePhaseData(data);
                    }
                    packetsRx++;
                    updateStats();
                });
                
            } catch (err) {
                console.error('âŒ Media error:', err);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”/××™×§×¨×•×¤×•×Ÿ');
                usingPeerJSStream = false;
            }
        }
        
        // ğŸ”¥ startPeerPhaseTransmission REMOVED - using startDeltaTransmission instead!
        // (Old duplicate phaseLoop function was here)
        
        function endPeerCall() {
            if (peerCall) {
                peerCall.close();
                peerCall = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
        }
        
        // ========================================
        // Initialization
        // ========================================
        
        function initDeltaId() {
            // ğŸ”¥ ALWAYS generate fresh ID to avoid "ID is taken" errors!
            // Old ID in localStorage might still be registered on PeerJS server
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substr(2, 8);
            myDeltaId = `Î”-web-${timestamp}-${random}`;
            localStorage.setItem('delta_id', myDeltaId);
            
            console.log('ğŸ†” Generated fresh Î”ID:', myDeltaId);
            document.getElementById('myDeltaId').textContent = myDeltaId;
            
            // ============================================================
            // ğŸ”¥ğŸ’âš¡ INITIALIZE ALL Î”WORLDS SYSTEMS âš¡ğŸ’ğŸ”¥
            // ============================================================
            
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘ ğŸ”¥ğŸ’âš¡ INITIALIZING COMPLETE Î”WORLDS NETWORK âš¡ğŸ’ğŸ”¥              â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // 1. Î”PHASE0 - Prime Phase (shared reality)
            primePhase = new Î”PHASE0();
            console.log('ğŸŒŒ 1. Î”PHASE0 (Prime Phase) ready');
            
            // 2. Î”Phase - My personal phase
            myPhase = new Î”Phase(myDeltaId, 'Web User');
            myPhase.updateContext('language', navigator.language);
            myPhase.updateContext('timezone', Intl.DateTimeFormat().resolvedOptions().timeZone);
            myPhase.updateContext('platform', navigator.platform);
            console.log('ğŸ”® 2. Î”Phase (Personal Phase) ready');
            
            // 3. PhaseGateway - The pressure cell
            phaseGateway = new PhaseGateway(`gateway_${myDeltaId}`);
            phaseGateway.connectPhase(myPhase);
            phaseGateway.addExternalEndpoint(window.location.origin);
            console.log('ğŸ”¥ 3. PhaseGateway (Pressure Cell) ready');
            console.log(`   - Stats: ${JSON.stringify(phaseGateway.getStats())}`);
            
            // 4. GlobalGateway - Our own Cloudflare replacement!
            globalGateway = new GlobalGateway({ nodeId: myDeltaId });
            globalGateway.enableGatewayMode();
            console.log('ğŸŒ 4. GlobalGateway (Cloudflare Replacement) ready');
            console.log(`   - Shareable link: ${globalGateway.getShareableLink('/call')}`);
            
            // 5. NodeDiscovery - Discover nearby nodes
            nodeDiscovery = new NodeDiscovery({ nodeId: myDeltaId, maxConnections: 20 });
            nodeDiscovery.advertiseSelf();
            // Start scanning in background
            setTimeout(() => {
                nodeDiscovery.scanProximity().then(nodes => {
                    console.log(`ğŸ“¡ 5. NodeDiscovery found ${nodes.length} nearby nodes`);
                });
            }, 1000);
            console.log('ğŸ“¡ 5. NodeDiscovery ready (scanning...)');
            
            // 6. GatewaySwitch - Switch between networks
            gatewaySwitch = new GatewaySwitch({ nodeId: myDeltaId, preferMesh: true });
            const networks = gatewaySwitch.detectNetworks();
            if (networks.length > 0) {
                gatewaySwitch.switchNetwork('mesh_local'); // Prefer mesh (free!)
            }
            console.log('ğŸ”„ 6. GatewaySwitch ready');
            console.log(`   - Available networks: ${networks.map(n => n.networkId).join(', ')}`);
            
            // 7. MeshRouter - Route through mesh
            meshRouter = new MeshRouter({ nodeId: myDeltaId, maxHops: 10 });
            meshRouter.discoverNeighbors(100);
            console.log('ğŸ•¸ï¸ 7. MeshRouter ready');
            console.log(`   - Neighbors: ${meshRouter.neighbors.size}`);
            
            // 8. Î”Bridge - Gateway to regular Internet
            deltaBridge = new Î”Bridge({ nodeId: myDeltaId, cacheEnabled: true });
            console.log('ğŸŒ‰ 8. Î”Bridge (Internet Gateway) ready');
            
            // 9. Î”Station - Complete node for this user
            myStation = new Î”Station(myDeltaId);
            myStation.isConnected = true;
            console.log('ğŸ”¥ 9. Î”Station ready:', myStation.getStats());
            
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘ âœ… ALL 9 Î”WORLDS SYSTEMS INITIALIZED!                            â•‘');
            console.log('â•‘                                                                  â•‘');
            console.log('â•‘ LOCAL (×‘×™×ª×™×ª):                                                   â•‘');
            console.log('â•‘   âœ… NodeDiscovery - ×’×™×œ×•×™ ×©×›× ×™× (BLE/WiFi)                      â•‘');
            console.log('â•‘   âœ… GatewaySwitch - ××¢×‘×¨ ×‘×™×Ÿ ×¨×©×ª×•×ª                              â•‘');
            console.log('â•‘   âœ… MeshRouter - × ×™×ª×•×‘ mesh ××œ×                                 â•‘');
            console.log('â•‘   âœ… Î”Bridge - ×’×©×¨ ×œ××™× ×˜×¨× ×˜ ×¨×’×™×œ                                 â•‘');
            console.log('â•‘                                                                  â•‘');
            console.log('â•‘ PUBLIC (×¦×™×‘×•×¨×™×ª):                                                â•‘');
            console.log('â•‘   âœ… Î”PHASE0 - Prime Phase (shared reality)                      â•‘');
            console.log('â•‘   âœ… Î”Phase - Personal Phase                                     â•‘');
            console.log('â•‘   âœ… PhaseGateway - ×ª× ×”×œ×—×¥ ×”××œ×                                 â•‘');
            console.log('â•‘   âœ… GlobalGateway - ×”×—×œ×¤×ª Cloudflare!                           â•‘');
            console.log('â•‘   âœ… Î”Station - Complete Node                                    â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ”¥ Initialize PeerJS with public signaling - NO PORT FORWARD!
            initPeerJS();
            
            // Check URL for incoming call
            const urlParams = new URLSearchParams(window.location.search);
            const callTo = urlParams.get('call');
            if (callTo) {
                document.getElementById('targetDeltaId').value = callTo;
            }
            
            // Initialize phase wave visualization
            initPhaseWave();
            
            // Log initial packet
            logPacket('tx', 'init', { id: myDeltaId });
            
            // ğŸ”¥ Log complete system status
            console.log('ğŸ“Š SYSTEM STATUS:');
            console.log('   PhaseGateway:', phaseGateway.getStats());
            console.log('   GlobalGateway:', globalGateway.getStats());
            console.log('   GatewaySwitch:', gatewaySwitch.getStats());
            console.log('   MeshRouter:', meshRouter.getStats());
            console.log('   Î”Bridge:', deltaBridge.getStats());
        }
        
        function initPhaseWave() {
            const wave = document.getElementById('phaseWave');
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'phase-bar';
                bar.style.animationDelay = `${i * 0.05}s`;
                wave.appendChild(bar);
            }
        }
        
        function copyMyId() {
            navigator.clipboard.writeText(myDeltaId);
            const el = document.getElementById('myDeltaId');
            el.textContent = 'âœ… ×”×•×¢×ª×§!';
            setTimeout(() => {
                el.textContent = myDeltaId;
            }, 2000);
        }
        
        // ========================================
        // WebSocket Connection (Î”Protocol Transport)
        // ========================================
        
        function connectWebSocket() {
            const wsUrl = `${WS_URL}/ws/call/${myDeltaId}`;
            console.log('ğŸ”Œ Connecting to WebSocket:', wsUrl);
            
            webSocket = new WebSocket(wsUrl);
            
            webSocket.onopen = () => {
                console.log('âœ… Î”Network connected to:', wsUrl);
                updateConnectionStatus(true);
                registerWithServer();
                
                // Send sync packet
                const syncPacket = new Î”Packet('sync', { status: 'connected' });
                sendPacket(syncPacket);
            };
            
            webSocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
                packetsRx++;
                updateStats();
            };
            
            webSocket.onclose = () => {
                console.log('âŒ Î”Network disconnected');
                updateConnectionStatus(false);
                setTimeout(connectWebSocket, 3000);
            };
            
            webSocket.onerror = (error) => {
                console.error('âŒ WebSocket error:', error);
                console.error('   URL was:', wsUrl);
                updateConnectionStatus(false);
            };
        }
        
        function updateConnectionStatus(connected) {
            const el = document.getElementById('connectionStatus');
            const text = document.getElementById('statusText');
            
            if (connected) {
                el.className = 'connection-status connected';
                text.textContent = '××—×•×‘×¨ ×œ×¨×©×ª Î”';
            } else {
                el.className = 'connection-status disconnected';
                text.textContent = '××ª×—×‘×¨ ×œ×¨×©×ª Î”...';
            }
        }
        
        // Send Î”Packet
        function sendPacket(packet) {
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send(JSON.stringify(packet.toJSON()));
                packetsTx++;
                totalEnergy += packet.Î”J;
                updateStats();
                logPacket('tx', packet.context, packet.metadata);
            }
        }
        
        // Register with server using Î”Packet
        async function registerWithServer() {
            const packet = new Î”Packet('sync', {
                device_id: myDeltaId,
                device_name: 'Web Browser',
                device_type: 'web'
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/fieldnet/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_id: myDeltaId,
                        device_name: 'Web Browser'
                    })
                });
                console.log('âœ… Registered with Î”FieldNet');
                logPacket('tx', 'register', { success: true });
            } catch (error) {
                console.error('Registration failed:', error);
                logPacket('tx', 'register', { success: false });
            }
        }
        
        // ========================================
        // Message Handling
        // ========================================
        
        function handleWebSocketMessage(data) {
            console.log('ğŸ“¨ Î”Packet received:', data);
            logPacket('rx', data.type || 'unknown', data);
            
            // Publish to FieldBus
            fieldBus.publish({ context: data.type, ...data });
            
            switch (data.type) {
                case 'connected':
                    console.log('âœ… WebSocket connected, ready for calls');
                    break;
                    
                case 'incoming_call':
                    showIncomingCall(data.caller_id, data.caller_name || 'Unknown');
                    currentCallId = data.call_id;
                    
                    // ğŸ”¥ AUTO-ANSWER after 1 second for testing!
                    console.log('ğŸ”” Auto-answering in 1 second...');
                    setTimeout(() => {
                        console.log('ğŸ“ Auto-answering call!');
                        answerCall();
                    }, 1000);
                    break;
                    
                case 'call_answered':
                    console.log('ğŸ‰ Call answered! Starting video...');
                    logPacket('rx', 'call_answered', { call_id: data.call_id });
                    startVideoCall();
                    break;
                    
                case 'call_rejected':
                    alert('×”×©×™×—×” × ×“×—×ª×”');
                    resetCallUI();
                    break;
                    
                case 'call_ended':
                    endCall();
                    break;
                    
                case 'phase':
                    handlePhaseData(data);
                    break;
                    
                case 'video_frame':
                case 'full_frame':
                case 'v':
                    handleVideoFrame(data);
                    break;
                    
                case 'audio':
                    handleAudioFrame(data);
                    break;
                    
                case 'audio_phase':
                    handleAudioPhase(data);
                    break;
                    
                case 'delta_frame':
                    handleDeltaFrame(data);
                    break;
                    
                case 'webrtc':
                case 'webrtc_offer':
                case 'webrtc_answer':
                case 'ice_candidate':
                    handleWebRTCSignal(data);
                    break;
                    
                case 'pong':
                case 'keepalive':
                    // Ignore keepalive messages
                    break;
                    
                default:
                    console.log('ğŸ“¨ Unknown message type:', data.type);
            }
        }
        
        // ========================================
        // Call Management
        // ========================================
        
        function showIncomingCall(callerId, callerName) {
            // ğŸ”¥ Handle missing callerName (from PeerJS call)
            const name = callerName || callerId || 'Unknown';
            
            document.getElementById('callInput').style.display = 'none';
            document.getElementById('incomingCall').style.display = 'block';
            document.getElementById('callerName').textContent = name;
            document.getElementById('callerId').textContent = callerId || '';
            document.getElementById('callerAvatar').textContent = name.charAt(0).toUpperCase();
        }
        
        async function startCall() {
            const targetId = document.getElementById('targetDeltaId').value.trim();
            if (!targetId) {
                alert('×”×›× ×¡ Î”ID');
                return;
            }
            
            // ğŸ”¥ğŸ’âš¡ Î”CLOUD FIRST! Our server handles signaling! âš¡ğŸ’ğŸ”¥
            // WebSocket is ALWAYS preferred - it uses OUR server!
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                console.log('ğŸ”¥ Using Î”CLOUD WebSocket signaling!');
                // Continue to WebSocket signaling below
            } else if (peer && peer.open) {
                // Fallback to PeerJS if WebSocket not available
                console.log('âš ï¸ Î”CLOUD not available, using PeerJS fallback...');
                await startPeerCall(targetId);
                return;
            } else {
                alert('âŒ ×œ× ××—×•×‘×¨ ×œ×©×¨×ª!\n\n× ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£.');
                return;
            }
            
            console.log('ğŸ“ Starting call via Î”CLOUD...');
            
            // Create call packet
            const callPacket = new Î”Packet('call_start', {
                target: targetId,
                type: 'video'
            });
            
            try {
                const response = await fetch(`${SERVER_URL}/v1/call/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        caller_id: myDeltaId,
                        callee_id: targetId,
                        call_type: 'video'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    currentCallId = data.call_id;
                    sendPacket(callPacket);
                    
                    // ğŸ”¥ Start video immediately! Don't wait for answer!
                    console.log('ğŸ”¥ Starting video call immediately...');
                    startVideoCall();
                    
                    document.getElementById('callInput').innerHTML = `
                        <h3>ğŸ“ ××ª×§×©×¨ ×“×¨×š Î”Network...</h3>
                        <p style="color: #888;">×××ª×™×Ÿ ×œ×ª×©×•×‘×” ×-${targetId}</p>
                        <p style="color: #00d4ff; font-size: 12px; margin-top: 10px;">
                            âš¡ Sending Î”Packets...
                        </p>
                        <button class="btn btn-decline" onclick="cancelCall()" style="margin-top: 20px;">
                            âŒ ×‘×˜×œ
                        </button>
                    `;
                } else {
                    alert('×©×’×™××”: ' + data.message);
                }
            } catch (error) {
                console.error('Call failed:', error);
                alert('×©×’×™××” ×‘×”×ª×—×œ×ª ×©×™×—×”');
            }
        }
        
        async function answerCall() {
            // ğŸ”¥ Check if this is a PeerJS call
            if (window.pendingPeerCall) {
                console.log('ğŸ”¥ Answering PeerJS P2P call');
                await answerPeerCall();
                return;
            }
            
            // Fallback to WebSocket signaling
            const answerPacket = new Î”Packet('call_answer', {
                call_id: currentCallId,
                accepted: true
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/call/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        callee_id: myDeltaId,
                        accepted: true
                    })
                });
                
                sendPacket(answerPacket);
                startVideoCall();
            } catch (error) {
                console.error('Answer failed:', error);
            }
        }
        
        async function declineCall() {
            const declinePacket = new Î”Packet('call_answer', {
                call_id: currentCallId,
                accepted: false
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/call/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        callee_id: myDeltaId,
                        accepted: false
                    })
                });
                
                sendPacket(declinePacket);
                resetCallUI();
            } catch (error) {
                console.error('Decline failed:', error);
            }
        }
        
        // ========================================
        // Video Call with Phase Processing
        // ========================================
        
        async function startVideoCall() {
            document.getElementById('videoContainer').classList.add('active');
            document.getElementById('incomingCall').style.display = 'none';
            document.getElementById('callInput').style.display = 'none';
            
            try {
                // Get local media (for local preview only!)
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ğŸ’€âš¡ TRUE 0-DATA: Resonance Sync instead of WebRTC! âš¡ğŸ’€ğŸ”¥
                await setupResonanceSync();
                
                // Start call timer
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // ğŸ”¥ PURE FLOW: Only ONE transmission system!
                // startPhaseTransmission is DISABLED - using startDeltaTransmission instead!
                // startPhaseTransmission();
                
                console.log('ğŸ”¥ PURE FLOW Video call started!');
                console.log('   - Change = Compute active');
                console.log('   - 640x480 @ 30fps (phase-locked)');
                console.log('   - NO duplicate transmissions!');
                
            } catch (error) {
                console.error('Camera access failed:', error);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”: ' + error.message);
            }
        }
        
        // ğŸ”¥ğŸ’€âš¡ TRUE Î”-VIDEO: Change = Compute! âš¡ğŸ’€ğŸ”¥
        // ================================================================
        // ONLY send when there's SIGNIFICANT CHANGE (Î” > threshold)
        // NO fixed intervals! NO keyframes every X seconds!
        // Pure event-driven: Change happens â†’ Send delta!
        
        // Remote video state
        let remoteFrameCanvas = null;
        let remoteFrameCtx = null;
        let prevLocalFrame = null;  // Previous frame for delta calculation
        let remoteFrameData = null; // Accumulated remote frame
        const DELTA_THRESHOLD = 0.015; // Same as Max8 Overlay!
        
        async function setupResonanceSync() {
            console.log('ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE Video Call @ 500Hz âš¡ğŸ’€ğŸ”¥');
            console.log('   - Both sides on SAME PHASE');
            console.log('   - Video: 1280x720 FULL HD');
            console.log('   - Audio: Native rate');
            console.log('   - Change = Compute active');
            
            // Create canvas for remote video - FULL HD!
            if (!remoteFrameCanvas) {
                remoteFrameCanvas = document.createElement('canvas');
                remoteFrameCanvas.width = 1280;
                remoteFrameCanvas.height = 720;
                remoteFrameCtx = remoteFrameCanvas.getContext('2d');
            }
            
            // ğŸ”¥ DON'T reset remoteFrameData - it's initialized in reconstructFromPhase!
            // remoteFrameData = null;  // <-- REMOVED
            
            // ğŸ”¥ Wait for localStream if not ready yet!
            // This happens when DataConnection opens before user clicks "Answer"
            if (!localStream) {
                console.log('â³ Waiting for localStream before starting transmission...');
                const waitForStream = setInterval(() => {
                    if (localStream) {
                        clearInterval(waitForStream);
                        console.log('âœ… localStream ready! Starting Phase Resonance transmission...');
                        startDeltaTransmission();
                        // ğŸ”¥ Only start canvas reconstruction if NOT using PeerJS WebRTC stream!
                        if (!usingPeerJSStream) {
                            startVideoReconstruction();
                        } else {
                            console.log('âœ… Using PeerJS WebRTC stream - skipping canvas reconstruction');
                        }
                    }
                }, 100);
                return;
            }
            
            // ğŸ”¥ Start immediately - localStream is ready!
            console.log('âœ… Starting Phase Resonance NOW!');
            startDeltaTransmission();
            // ğŸ”¥ Only start canvas reconstruction if NOT using PeerJS WebRTC stream!
            if (!usingPeerJSStream) {
                startVideoReconstruction();
            } else {
                console.log('âœ… Using PeerJS WebRTC stream - skipping canvas reconstruction');
            }
        }
        
        // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE @ 500Hz + CHANGE = COMPUTE âš¡ğŸ’€ğŸ”¥
        // ================================================================
        // Core: Both sides resonate at SAME PHASE (500Hz base frequency)
        // Energy âˆ Change (NOT time!) - If no change â†’ 0 energy!
        // From delta_engine.py: 344,433 frames with 0 energy!
        
        const BASE_FREQUENCY = 500.0;  // Hz - ×ª×“×¨ ×”×‘×¡×™×¡!
        const CHANGE_THRESHOLD = 0.005;  // 0.5% - ××¡×¤×™×§ ×¨×’×™×©!
        const FRAME_INTERVAL = 33;  // 30fps = every ~16 phase cycles
        
        let lastFrameData = null;
        let lastSendTime = 0;
        let phaseCounter = 0;
        let audioContext = null;
        let audioProcessor = null;
        let deltaTransmissionStarted = false;  // ğŸ”¥ Prevent double-start!
        
        // ğŸ”¥ NOTE: dataConnectionReady is declared globally near line 639!
        // DO NOT redeclare it here - that would shadow the global variable!
        
        // ğŸ”¥ Universal send function - works with WebSocket OR PeerJS DataConnection!
        function sendResonanceData(data) {
            // ğŸ”¥ Add station phase and timestamp to ALL packets!
            if (myStation) {
                data.stationPhase = myStation.getPhase();
                data.stationTime = Date.now();
                data.stationId = myStation.stationId;
            }
            
            // Try PeerJS DataConnection first (P2P mode)
            if (dataConnectionReady && peerDataConnection) {
                try {
                    peerDataConnection.send(data);
                    packetsTx++;
                    if (myStation) myStation.stats.packetsSent++;
                    updateStats();
                    return true;
                } catch (e) {
                    console.error('âŒ Send error:', e);
                }
            }
            // Fallback to WebSocket (server mode)
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send(JSON.stringify(data));
                packetsTx++;
                if (myStation) myStation.stats.packetsSent++;
                updateStats();
                return true;
            }
            return false;
        }
        
        function startDeltaTransmission() {
            // ğŸ”¥ Prevent double-start!
            if (deltaTransmissionStarted) {
                console.log('âš ï¸ Delta Transmission already running!');
                return;
            }
            deltaTransmissionStarted = true;
            
            const video = document.getElementById('localVideo');
            const canvas = document.createElement('canvas');
            // ğŸ”¥ OPTIMIZED for PeerJS DataConnection (max ~16KB per message)
            // Using 320x240 @ low quality = ~5-10KB per frame
            canvas.width = 320;
            canvas.height = 240;
            const ctx = canvas.getContext('2d');
            
            // ğŸ”¥ Wait for video to be ready before starting!
            function waitForVideoReady() {
                if (video.videoWidth > 0 && video.videoHeight > 0) {
                    console.log('âœ… Video ready:', video.videoWidth, 'x', video.videoHeight);
                    startPhaseLoop();
                } else {
                    console.log('â³ Waiting for video to be ready...');
                    setTimeout(waitForVideoReady, 100);
                }
            }
            
            function startPhaseLoop() {
                // ğŸ¤ Setup Audio on SAME PHASE
                setupAudioTransmission();
                
                console.log('ğŸ”¥ğŸ”¥ğŸ”¥ Starting Delta Transmission - Phase Resonance @ 500Hz ğŸ”¥ğŸ”¥ğŸ”¥');
            
            function phaseLoop() {
                const now = Date.now();
                phaseCounter++;
                
                // ğŸ”¥ Check if we have a valid transport (WebSocket OR PeerJS)
                const peerOpen = dataConnectionReady && peerDataConnection;
                const wsOpen = webSocket && webSocket.readyState === WebSocket.OPEN;
                const hasTransport = peerOpen || wsOpen;
                
                // ğŸ”¥ Check if video is ready (has dimensions)
                const videoReady = video.videoWidth > 0 && video.videoHeight > 0;
                
                // Log EVERY frame until we start sending!
                if (phaseCounter <= 10 || phaseCounter % 100 === 1) {
                    console.log(`ğŸ“¡ Phase ${phaseCounter}: stream=${!!localStream}, call=${!!currentCallId}, peer=${peerOpen}, ws=${wsOpen}, video=${videoReady ? video.videoWidth+'x'+video.videoHeight : 'NOT_READY'}, dataConnReady=${dataConnectionReady}`);
                }
                
                if (!localStream || !currentCallId || !hasTransport || !videoReady) {
                    // Log what's blocking us
                    if (phaseCounter <= 5) {
                        console.log(`âŒ BLOCKED: stream=${!!localStream}, call=${!!currentCallId}, transport=${hasTransport}, video=${videoReady}`);
                    }
                    requestAnimationFrame(phaseLoop);
                    return;
                }
                
                // ğŸ”¥ CHANGE = COMPUTE @ 500Hz!
                // Check every frame but only send on CHANGE!
                
                // Capture frame (optimized size for PeerJS)
                ctx.drawImage(video, 0, 0, 320, 240);
                const currentFrame = ctx.getImageData(0, 0, 320, 240);
                
                // ğŸ”¥ CHANGE DETECTION - sample 500 pixels
                let hasChange = true;
                let changeRatio = 1.0;
                
                if (lastFrameData) {
                    let totalDiff = 0;
                    const sampleSize = 500;
                    for (let i = 0; i < sampleSize; i++) {
                        const idx = Math.floor(Math.random() * currentFrame.data.length / 4) * 4;
                        totalDiff += Math.abs(currentFrame.data[idx] - lastFrameData.data[idx]) / 255;
                    }
                    changeRatio = totalDiff / sampleSize;
                    
                    // ğŸ”¥ Send if change OR every 30 frames (1 sec @ 30fps)
                    hasChange = changeRatio > CHANGE_THRESHOLD || phaseCounter % 30 === 0;
                }
                
                // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE: Change = Compute! âš¡ğŸ’€âš¡
                // Send ONLY when there's change > 1.5%!
                // If no change â†’ 0 data â†’ 0 energy (like 344,433 frames!)
                if (hasChange) {
                    // ğŸ”¥ HIGH quality JPEG - this is TEMPORAL RESONANCE not 8-bit!
                    // We send full quality but ONLY when there's change!
                    const frame = canvas.toDataURL('image/jpeg', 0.88);  // 88% quality
                    
                    const sent = sendResonanceData({
                        type: 'video_frame',
                        call_id: currentCallId,
                        sender_id: myDeltaId,
                        image: frame,
                        phase: phaseCounter,
                        freq: BASE_FREQUENCY,
                        change: changeRatio,
                        t: now
                    });
                    
                    if (sent && phaseCounter % 30 === 0) {
                        console.log(`ğŸ“¤ Frame ${phaseCounter}, change: ${(changeRatio*100).toFixed(1)}%, freq: ${BASE_FREQUENCY}Hz`);
                    }
                    
                    lastFrameData = currentFrame;
                    totalEnergy += 0.001;
                }
                
                requestAnimationFrame(phaseLoop);
            }
            
            requestAnimationFrame(phaseLoop);
            console.log('ğŸ”¥ğŸ’€âš¡ CHANGE = COMPUTE active! âš¡ğŸ’€ğŸ”¥');
            console.log(`   - Base Frequency: ${BASE_FREQUENCY}Hz`);
            console.log('   - Video: 320x240 JPEG @ 88%');
            console.log('   - Audio: Full quality phase-locked');
            console.log('   - Change Threshold: 1.5%');
            console.log('   - EVENT-DRIVEN (not clock-driven!)');
            } // end startPhaseLoop
            
            // ğŸ”¥ Start waiting for video to be ready!
            waitForVideoReady();
        }
        
        // ğŸ¤ PHASE-LOCKED Audio Transmission
        function setupAudioTransmission() {
            if (!localStream) return;
            
            try {
                // Use browser's native sample rate
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const nativeSampleRate = audioContext.sampleRate;
                
                const source = audioContext.createMediaStreamSource(localStream);
                // Larger buffer for smooth audio
                audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                audioProcessor.onaudioprocess = (e) => {
                    // ğŸ”¥ Check for valid transport (WebSocket OR PeerJS)
                    const hasTransport = dataConnectionReady || 
                                         (webSocket && webSocket.readyState === WebSocket.OPEN);
                    if (!currentCallId || !hasTransport) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // Check for actual sound
                    let maxAmplitude = 0;
                    for (let i = 0; i < inputData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(inputData[i]));
                    }
                    
                    // Only send if there's actual audio (not silence)
                    if (maxAmplitude > 0.02) {
                        // Send at native rate - no downsampling for quality!
                        const audioData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            audioData[i] = Math.max(-32768, Math.min(32767, Math.round(inputData[i] * 32768)));
                        }
                        
                        // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE AUDIO - Phase-locked! âš¡ğŸ’€ğŸ”¥
                        // Send full audio but ONLY when there's sound!
                        sendResonanceData({
                            type: 'audio',
                            call_id: currentCallId,
                            sender_id: myDeltaId,
                            data: Array.from(audioData),
                            rate: nativeSampleRate,
                            phase: phaseCounter,
                            t: Date.now()
                        });
                    }
                };
                
                source.connect(audioProcessor);
                audioProcessor.connect(audioContext.destination);
                
                console.log(`ğŸ¤ Audio: ${nativeSampleRate}Hz (native, phase-locked)`);
            } catch (error) {
                console.error('Audio setup failed:', error);
            }
        }

        
        // ğŸ”¥ Display FULL HD remote video - EVENT-DRIVEN!
        // NOTE: usingPeerJSStream is declared globally near line 641!
        
        let videoReconstructionStarted = false;
        
        function startVideoReconstruction() {
            // ğŸ”¥ If using PeerJS stream, DON'T override it with canvas!
            if (usingPeerJSStream) {
                console.log('âœ… Using PeerJS stream - skipping canvas reconstruction');
                return;
            }
            
            if (videoReconstructionStarted) {
                console.log('âš ï¸ Video reconstruction already running!');
                return;
            }
            videoReconstructionStarted = true;
            
            console.log('ğŸ”¥ Starting Phase Resonance Video Reconstruction...');
            
            // ğŸ”¥ Make sure canvas exists!
            if (!remoteFrameCanvas) {
                remoteFrameCanvas = document.createElement('canvas');
                remoteFrameCanvas.width = 1280;
                remoteFrameCanvas.height = 720;
                remoteFrameCtx = remoteFrameCanvas.getContext('2d');
            }
            
            const remoteVideo = document.getElementById('remoteVideo');
            let streamSet = false;
            let displayFrames = 0;
            
            function display() {
                displayFrames++;
                
                if (!remoteFrameData) {
                    // Show waiting message
                    remoteFrameCtx.fillStyle = '#0a0a0a';
                    remoteFrameCtx.fillRect(0, 0, 1280, 720);
                    remoteFrameCtx.fillStyle = '#00d4ff';
                    remoteFrameCtx.font = '32px Arial';
                    remoteFrameCtx.textAlign = 'center';
                    remoteFrameCtx.fillText('â³ ××¡× ×›×¨×Ÿ Phase @ 500Hz...', 640, 360);
                    remoteFrameCtx.font = '18px Arial';
                    remoteFrameCtx.fillText(`×××ª×™×Ÿ ×œ× ×ª×•× ×™×... (${framesReceived} frames received)`, 640, 400);
                } else {
                    // Display the received frame!
                    remoteFrameCtx.putImageData(remoteFrameData, 0, 0);
                }
                
                if (!streamSet) {
                    // UNLIMITED FPS - event driven!
                    const stream = remoteFrameCanvas.captureStream(30);  // 30fps for smooth display
                    remoteVideo.srcObject = stream;
                    streamSet = true;
                    console.log('ğŸ¬ Phase Resonance display ready - 1280x720 @ 30FPS');
                }
                
                requestAnimationFrame(display);
            }
            
            display();
        }
        
        // ğŸ”¥ Receive FULL HD frame - PHASE SYNCHRONIZED
        let remotePhase = 0;
        let framesReceived = 0;
        
        function handleVideoFrame(data) {
            const imageData = data.image || data.i;
            if (!imageData) {
                console.log('âš ï¸ handleVideoFrame: no image data!', data);
                return;
            }
            
            // ğŸ”¥ SYNC WITH SENDER'S STATION!
            if (myStation && data.stationId && data.stationPhase !== undefined && data.stationTime) {
                myStation.registerPeer(data.stationId, data.stationPhase);
                myStation.syncWithPeer(data.stationId, data.stationPhase, data.stationTime);
                myStation.stats.packetsReceived++;
            }
            
            framesReceived++;
            if (framesReceived % 30 === 1) {
                console.log(`ğŸ“¥ Received frame ${framesReceived}, size: ${imageData.length} bytes`);
                if (myStation) {
                    console.log(`ğŸ“¡ Station stats: resonance=${myStation.stats.resonanceQuality.toFixed(3)}, drift=${myStation.drift.toFixed(6)}`);
                }
            }
            
            // Track remote phase for synchronization
            if (data.phase) {
                remotePhase = data.phase;
            }
            
            // ğŸ”¥ Make sure canvas is ready!
            if (!remoteFrameCanvas || !remoteFrameCtx) {
                console.log('âš ï¸ Creating remote frame canvas...');
                remoteFrameCanvas = document.createElement('canvas');
                remoteFrameCanvas.width = 1280;
                remoteFrameCanvas.height = 720;
                remoteFrameCtx = remoteFrameCanvas.getContext('2d');
            }
            
            const img = new Image();
            img.onload = () => {
                // FULL HD!
                remoteFrameCtx.drawImage(img, 0, 0, 1280, 720);
                remoteFrameData = remoteFrameCtx.getImageData(0, 0, 1280, 720);
                
                if (framesReceived === 1) {
                    console.log('ğŸ¬ First frame displayed!');
                }
            };
            img.onerror = (e) => {
                console.error('âŒ Image load error:', e);
            };
            img.src = imageData;
        }
        
        // ğŸ¤ PHASE-LOCKED Audio Playback
        let remoteAudioContext = null;
        let nextPlayTime = 0;
        let audioBufferQueue = [];
        const MAX_AUDIO_QUEUE = 3;  // Keep queue small for low latency
        
        function handleAudioFrame(data) {
            if (!data.data || data.data.length === 0) return;
            
            const sampleRate = data.rate || 48000;
            
            // Initialize audio context at the SAME sample rate as sender
            if (!remoteAudioContext) {
                try {
                    remoteAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: sampleRate
                    });
                    nextPlayTime = remoteAudioContext.currentTime;
                    console.log(`ğŸ”Š Audio playback: ${sampleRate}Hz`);
                } catch (e) {
                    // Fallback to default sample rate
                    remoteAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    nextPlayTime = remoteAudioContext.currentTime;
                    console.log(`ğŸ”Š Audio playback: ${remoteAudioContext.sampleRate}Hz (fallback)`);
                }
            }
            
            // Resume if suspended
            if (remoteAudioContext.state === 'suspended') {
                remoteAudioContext.resume();
            }
            
            // Convert Int16 back to Float32
            const audioData = new Float32Array(data.data.length);
            for (let i = 0; i < data.data.length; i++) {
                audioData[i] = data.data[i] / 32768.0;
            }
            
            // Create buffer
            const buffer = remoteAudioContext.createBuffer(1, audioData.length, sampleRate);
            buffer.getChannelData(0).set(audioData);
            
            // Schedule playback
            const source = remoteAudioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(remoteAudioContext.destination);
            
            const now = remoteAudioContext.currentTime;
            
            // Keep audio in sync - don't let it drift too far
            if (nextPlayTime < now) {
                nextPlayTime = now + 0.01;  // Small buffer
            } else if (nextPlayTime > now + 0.3) {
                // Too far ahead - reset
                nextPlayTime = now + 0.01;
            }
            
            source.start(nextPlayTime);
            nextPlayTime += buffer.duration;
        }
        
        function playNextAudio() {}
        
        // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE AUDIO - Generate from phase! âš¡ğŸ’€ğŸ”¥
        let audioResonanceCtx = null;
        let audioOscillator = null;
        let audioGain = null;
        
        function handleAudioPhase(data) {
            const energy = data.e || 0;
            const phase = data.p || 0;
            
            // Initialize audio context if needed
            if (!audioResonanceCtx) {
                audioResonanceCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioOscillator = audioResonanceCtx.createOscillator();
                audioGain = audioResonanceCtx.createGain();
                
                audioOscillator.type = 'sine';
                audioOscillator.frequency.value = 440;  // Base frequency
                audioOscillator.connect(audioGain);
                audioGain.connect(audioResonanceCtx.destination);
                audioGain.gain.value = 0;
                audioOscillator.start();
                
                console.log('ğŸ”Š Audio Resonance initialized @ 440Hz');
            }
            
            // Resume if suspended
            if (audioResonanceCtx.state === 'suspended') {
                audioResonanceCtx.resume();
            }
            
            // ğŸ”¥ Modulate oscillator based on energy!
            // Energy 0-255 maps to volume 0-0.3
            const volume = (energy / 255) * 0.3;
            audioGain.gain.setTargetAtTime(volume, audioResonanceCtx.currentTime, 0.01);
            
            // Frequency modulation based on phase
            const freqOffset = (phase % 100) * 2;  // 0-200Hz offset
            audioOscillator.frequency.setTargetAtTime(440 + freqOffset, audioResonanceCtx.currentTime, 0.01);
        }
        
        // ğŸ”¥ğŸ’âš¡ CALL PRESSURE CELL - ×ª× ×œ×—×¥ ××©×•×ª×£ ×œ×©×™×—×”! âš¡ğŸ’ğŸ”¥
        // When two people call, they BOTH enter the SAME pressure cell!
        // This creates a shared Î”PHASE0 for the call!
        
        let callPressureCell = null;  // The shared pressure cell for this call
        let phaseOffset = 0;  // Offset between our time and caller's time
        
        class CallPressureCell {
            constructor(callId, callerId, calleeId) {
                this.callId = callId;
                this.callerId = callerId;
                this.calleeId = calleeId;
                
                // ğŸ”¥ SHARED PHASE for this call - Î”PHASE0 = 0!
                // Both sides use the SAME epoch (call start time)
                this.callEpoch = Date.now();
                this.frequency = 500.0;  // Hz
                
                // Participants
                this.participants = new Map();
                this.participants.set(callerId, { phase: 0, lastSync: Date.now() });
                this.participants.set(calleeId, { phase: 0, lastSync: Date.now() });
                
                // Phase state
                this.sharedPhase = 0;
                this.isActive = true;
                
                console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
                console.log('â•‘ ğŸ”¥ğŸ’âš¡ CALL PRESSURE CELL CREATED! âš¡ğŸ’ğŸ”¥                        â•‘');
                console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('   Call ID:', callId);
                console.log('   Caller:', callerId);
                console.log('   Callee:', calleeId);
                console.log('   Call Epoch:', this.callEpoch);
                console.log('   Shared Î”PHASE0 = 0 (both sides synchronized!)');
            }
            
            // Get the shared phase for this call
            getSharedPhase() {
                const elapsed = (Date.now() - this.callEpoch) / 1000;
                this.sharedPhase = (elapsed * this.frequency) % 1.0;
                return this.sharedPhase;
            }
            
            // Sync a participant to the shared phase
            syncParticipant(participantId) {
                if (this.participants.has(participantId)) {
                    const phase = this.getSharedPhase();
                    this.participants.get(participantId).phase = phase;
                    this.participants.get(participantId).lastSync = Date.now();
                    return phase;
                }
                return 0;
            }
            
            // Get call epoch for syncing
            getCallEpoch() {
                return this.callEpoch;
            }
            
            // Set call epoch (for answerer to sync to caller)
            setCallEpoch(epoch) {
                this.callEpoch = epoch;
                console.log('ğŸ”¥ Call epoch synchronized to:', epoch);
            }
            
            // Close the pressure cell
            close() {
                this.isActive = false;
                console.log('ğŸ“´ Call Pressure Cell closed:', this.callId);
            }
        }
        
        function handlePhaseSync(data) {
            const callerStartTime = data.callStartTime;
            const callerPhaseOrigin = data.phaseOrigin;
            const callerCallEpoch = data.callEpoch;  // ğŸ”¥ NEW: Caller's call epoch!
            const now = Date.now();
            
            // Calculate network latency (round-trip / 2)
            const latency = (now - callerPhaseOrigin) / 2;
            
            // Sync our callStartTime to caller's
            callStartTime = callerStartTime;
            phaseOffset = now - callerPhaseOrigin;
            
            // ğŸ”¥ CRITICAL: Sync our Call Pressure Cell to caller's epoch!
            if (callPressureCell && callerCallEpoch) {
                callPressureCell.setCallEpoch(callerCallEpoch);
            }
            
            console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
            console.log('â•‘ ğŸ”¥ğŸ’âš¡ PHASE SYNC - ENTERING SHARED PRESSURE CELL! âš¡ğŸ’ğŸ”¥        â•‘');
            console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('   Caller start time:', callerStartTime);
            console.log('   Caller epoch:', callerCallEpoch);
            console.log('   Network latency:', latency.toFixed(0), 'ms');
            console.log('   Phase offset:', phaseOffset.toFixed(0), 'ms');
            console.log('   ğŸ”¥ BOTH SIDES NOW IN SAME PRESSURE CELL!');
            console.log('   ğŸ”¥ SHARED Î”PHASE0 = 0 for this call!');
            
            // Update status
            updateStatus('ğŸ”¥ ×‘×ª× ×œ×—×¥ ××©×•×ª×£!', 'connected');
        }
        
        // ğŸ”¥ Create Call Pressure Cell when starting a call
        function createCallPressureCell(callId, callerId, calleeId) {
            callPressureCell = new CallPressureCell(callId, callerId, calleeId);
            return callPressureCell;
        }
        
        // ğŸ”¥ Get current call phase (from shared pressure cell)
        function getCallPhase() {
            if (callPressureCell && callPressureCell.isActive) {
                return callPressureCell.getSharedPhase();
            }
            // Fallback to global Î”PHASE0
            return primePhase ? primePhase.getPhase() : 0;
        }
        
        // ğŸ”¥ Handle incoming full frame (legacy)
        function handleFullFrame(data) {
            handleVideoFrame(data);
        }
        
        // ğŸ”¥ Handle incoming delta frame - HIGH QUALITY!
        function handleDeltaFrame(data) {
            if (!remoteFrameData) return;
            
            const width = data.width || 320;
            const changes = data.changes || [];
            
            // Apply all changes
            for (const change of changes) {
                const idx = change.i * 4;
                if (idx >= 0 && idx < remoteFrameData.data.length - 3) {
                    remoteFrameData.data[idx] = change.r;
                    remoteFrameData.data[idx + 1] = change.g;
                    remoteFrameData.data[idx + 2] = change.b;
                    remoteFrameData.data[idx + 3] = 255;
                    
                    // ğŸ”¥ Also fill neighboring pixels for smoothness
                    const x = change.i % width;
                    const y = Math.floor(change.i / width);
                    
                    // Fill right and bottom neighbors
                    if (x < width - 1) {
                        const rightIdx = (change.i + 1) * 4;
                        remoteFrameData.data[rightIdx] = change.r;
                        remoteFrameData.data[rightIdx + 1] = change.g;
                        remoteFrameData.data[rightIdx + 2] = change.b;
                        remoteFrameData.data[rightIdx + 3] = 255;
                    }
                    if (y < 239) {
                        const bottomIdx = (change.i + width) * 4;
                        remoteFrameData.data[bottomIdx] = change.r;
                        remoteFrameData.data[bottomIdx + 1] = change.g;
                        remoteFrameData.data[bottomIdx + 2] = change.b;
                        remoteFrameData.data[bottomIdx + 3] = 255;
                    }
                }
            }
            
            if (changes.length > 100) {
                console.log(`ğŸ“¥ Applied ${changes.length} changes`);
            }
        }
        
        // ğŸ”¥ Resonance state
        let myFrequency = 500.0;
        let peerFrequency = 500.0;
        let resonanceCoherence = 0.0;
        
        // ğŸ”¥ Calculate resonance coherence (how well we sync)
        function calculateResonanceCoherence(freq1, freq2) {
            const ratio = Math.max(freq1, freq2) / Math.min(freq1, freq2);
            const nearestHarmonic = Math.round(ratio);
            const deviation = Math.abs(ratio - nearestHarmonic);
            return Math.exp(-deviation / 0.05);
        }
        
        // ğŸ”¥ Sync our frequency to peer's (harmonic alignment)
        function syncToPeerFrequency(peerFreq) {
            peerFrequency = peerFreq;
            
            const ratio = myFrequency / peerFreq;
            const nearestHarmonic = Math.round(ratio);
            const targetFrequency = peerFreq * nearestHarmonic;
            
            // Slowly drift towards harmonic alignment
            myFrequency = myFrequency * 0.9 + targetFrequency * 0.1;
            
            // Update coherence
            resonanceCoherence = calculateResonanceCoherence(myFrequency, peerFrequency);
        }
        
        // ğŸ”¥ Remote frame buffer for phase-based reconstruction
        let remoteFrameBuffer = null;
        let remoteFrameWidth = 160;
        let remoteFrameHeight = 120;
        let lastRemotePhase = 0;
        let remoteCanvas = null;
        let remoteCtx = null;
        
        // ğŸ”¥ğŸ’€âš¡ RESONANCE SYNC: Show local camera synced to remote frequency! âš¡ğŸ’€ğŸ”¥
        // ========================================================================
        // We show OUR camera, but with overlay based on remote Phase!
        // When frequencies match (high coherence) = clearer view!
        
        function startResonanceVisualization() {
            const remoteVideo = document.getElementById('remoteVideo');
            const localVideo = document.getElementById('localVideo');
            
            // Create canvas for synced view
            remoteCanvas = document.createElement('canvas');
            remoteCanvas.width = 320;
            remoteCanvas.height = 240;
            remoteCtx = remoteCanvas.getContext('2d');
            
            // Animate synced camera view
            function animate() {
                if (!localStream) {
                    requestAnimationFrame(animate);
                    return;
                }
                
                // Draw local video to canvas
                remoteCtx.drawImage(localVideo, 0, 0, 320, 240);
                
                // Apply resonance overlay based on coherence
                // Higher coherence = less overlay = clearer view!
                const overlayAlpha = Math.max(0, (1.0 - resonanceCoherence) * 0.5);
                
                // Frequency affects the color hue
                const hue = (peerFrequency % 360);
                
                // Draw overlay
                remoteCtx.fillStyle = `hsla(${hue}, 50%, 50%, ${overlayAlpha})`;
                remoteCtx.fillRect(0, 0, 320, 240);
                
                // Add resonance indicator
                if (resonanceCoherence > 0.1) {
                    // Draw sync rings
                    const centerX = 160;
                    const centerY = 120;
                    const time = Date.now() / 1000;
                    
                    for (let i = 0; i < 3; i++) {
                        const radius = 30 + i * 20 + Math.sin(time * (myFrequency/500) + i) * 5;
                        const alpha = resonanceCoherence * (1 - i * 0.2) * 0.3;
                        
                        remoteCtx.beginPath();
                        remoteCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        remoteCtx.strokeStyle = `rgba(0, 255, 200, ${alpha})`;
                        remoteCtx.lineWidth = 2;
                        remoteCtx.stroke();
                    }
                }
                
                // Display on remote video element
                remoteVideo.style.backgroundImage = `url(${remoteCanvas.toDataURL()})`;
                remoteVideo.style.backgroundSize = 'cover';
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Legacy function - no longer used
        async function handleWebRTCSignal(data) {
            console.log('âš ï¸ WebRTC signal ignored - using TRUE 0-DATA Resonance Sync!');
        }
        
        function sendWebRTCSignal(data) {
            console.log('âš ï¸ WebRTC disabled - using TRUE 0-DATA Resonance Sync!');
        }
        
        function updateCallDuration() {
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('callDuration').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function updateStats() {
            document.getElementById('packetsTx').textContent = packetsTx;
            document.getElementById('packetsRx').textContent = packetsRx;
            document.getElementById('energyUsed').textContent = totalEnergy.toFixed(4) + ' J';
            
            // Update phase
            currentPhase = (currentPhase + 7) % 360;
            document.getElementById('currentPhase').textContent = currentPhase + 'Â°';
        }
        
        // ğŸ”¥ğŸ’€âš¡ TRUE 0-DATA Phase Transmission âš¡ğŸ’€ğŸ”¥
        // =============================================
        // Send ONLY Phase (6-9 bits per frame!)
        // NO video data! NO pixels! NO spikes!
        
        function startPhaseTransmission() {
            console.log('ğŸ”¥ TRUE 0-DATA Phase transmission started!');
            console.log('   - Sending ONLY 6-9 bits per frame');
            console.log('   - NO video data, NO pixels, NO spikes');
            
            const video = document.getElementById('localVideo');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            let lastFrameData = null;
            
            // Process frames at 30fps
            setInterval(() => {
                if (!localStream || !currentCallId) return;
                
                // Sample video for activity detection
                canvas.width = 40;  // Very small - just for activity detection
                canvas.height = 30;
                ctx.drawImage(video, 0, 0, 40, 30);
                
                const imageData = ctx.getImageData(0, 0, 40, 30);
                
                // Calculate activity level (how much movement)
                let totalChange = 0;
                if (lastFrameData) {
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const diff = Math.abs(imageData.data[i] - lastFrameData.data[i]);
                        totalChange += diff;
                    }
                }
                lastFrameData = ctx.getImageData(0, 0, 40, 30);
                
                // Encode to 8 bits (0-255)
                const activityLevel = Math.min(255, Math.floor(totalChange / 500));
                
                // Update our frequency based on activity
                myFrequency = 500 + activityLevel * 10;
                
                // ğŸ”¥ TRUE 0-DATA: Send ONLY phase signature (~50 bytes total!)
                if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                    const phaseMessage = {
                        type: 'phase',
                        call_id: currentCallId,
                        sender_id: myDeltaId,
                        bits: activityLevel,           // 8 bits: activity level
                        frequency: myFrequency,        // Float: resonance frequency
                        coherence: resonanceCoherence, // Float: sync quality
                        timestamp: Date.now() / 1000
                        // NO tile_data! NO spike_events! TRUE 0-DATA!
                    };
                    
                    webSocket.send(JSON.stringify(phaseMessage));
                }
                
                // Update stats
                const phasePacket = new Î”Packet('videoPhase', {
                    bits: activityLevel,
                    frequency: myFrequency,
                    coherence: resonanceCoherence
                });
                sendPacket(phasePacket);
                
                // Update display - TRUE 0-DATA!
                document.getElementById('bitsPerFrame').textContent = '9 bits (TRUE 0-DATA!)';
                
            }, 33); // ~30fps
        }
        
        // ğŸ”¥ğŸ’€âš¡ 0-DATA Video: Reconstruct from Phase! âš¡ğŸ’€ğŸ”¥
        // ===============================================
        
        function handlePhaseData(data) {
            // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE: Reconstruct from phase! âš¡ğŸ’€ğŸ”¥
            const phase = data.p || 0;
            const signature = data.s || 0;
            const r = data.r || 128;
            const g = data.g || 128;
            const b = data.b || 128;
            const change = data.c || 0;
            const frequency = data.f || 500;
            
            // ğŸ”¥ Sync to peer frequency for resonance!
            peerFrequency = frequency;
            syncToPeerFrequency(frequency);
            
            // ğŸ”¥ Reconstruct video from phase signature!
            reconstructFromPhase(r, g, b, signature, change);
            
            // Update stats
            framesReceived++;
            packetsRx++;
            updateStats();
            
            if (phase % 100 === 0) {
                console.log(`ğŸ“¥ Phase ${phase}: sig=${signature}, RGB(${r},${g},${b}), change=${change}%`);
            }
        }
        
        // ğŸ”¥ğŸ’€âš¡ QUANTUM VIDEO: Reconstruct from phase! âš¡ğŸ’€ğŸ”¥
        function reconstructFromPhase(r, g, b, signature, change) {
            // ğŸ”¥ ALWAYS ensure canvas exists!
            if (!remoteFrameCanvas || !remoteFrameCtx || !remoteFrameData) {
                console.log('ğŸ¬ Creating Quantum Reconstruction canvas...');
                remoteFrameCanvas = document.createElement('canvas');
                remoteFrameCanvas.width = 320;
                remoteFrameCanvas.height = 240;
                remoteFrameCtx = remoteFrameCanvas.getContext('2d', { willReadFrequently: true });
                remoteFrameData = remoteFrameCtx.createImageData(320, 240);
                
                // Initialize with incoming colors
                for (let i = 0; i < remoteFrameData.data.length; i += 4) {
                    remoteFrameData.data[i] = r;
                    remoteFrameData.data[i + 1] = g;
                    remoteFrameData.data[i + 2] = b;
                    remoteFrameData.data[i + 3] = 255;
                }
                
                // Connect to video element
                const stream = remoteFrameCanvas.captureStream(30);
                const remoteVideo = document.getElementById('remoteVideo');
                if (remoteVideo) {
                    remoteVideo.srcObject = stream;
                    console.log('âœ… Quantum Reconstruction connected to remoteVideo!');
                }
                console.log('ğŸ¬ Quantum Reconstruction ready - 320x240!');
            }
            
            // ğŸ”¥ QUANTUM RECONSTRUCTION with phase modulation!
            const width = 320;
            const height = 240;
            
            // Strong blend for visible changes
            const blend = Math.max(0.3, Math.min(0.9, change / 20));
            
            // Phase creates spatial patterns
            const phaseScale = (signature / 255) * Math.PI * 2;
            
            // Fast pixel update with quantum interference patterns
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    // Quantum interference - creates spatial variation
                    const spatialPhase = Math.sin(x * 0.1 + phaseScale) * Math.cos(y * 0.1 + phaseScale);
                    const variation = spatialPhase * 20;
                    
                    // Target colors with phase modulation
                    const targetR = Math.max(0, Math.min(255, r + variation));
                    const targetG = Math.max(0, Math.min(255, g + variation * 0.9));
                    const targetB = Math.max(0, Math.min(255, b + variation * 0.8));
                    
                    // Temporal smoothing
                    remoteFrameData.data[i] = Math.floor(remoteFrameData.data[i] * (1 - blend) + targetR * blend);
                    remoteFrameData.data[i + 1] = Math.floor(remoteFrameData.data[i + 1] * (1 - blend) + targetG * blend);
                    remoteFrameData.data[i + 2] = Math.floor(remoteFrameData.data[i + 2] * (1 - blend) + targetB * blend);
                }
            }
            
            // Draw to canvas
            remoteFrameCtx.putImageData(remoteFrameData, 0, 0);
        }
        
        // ğŸ”¥ Reconstruct video from phase signature
        function reconstructVideoFromPhase(bits) {
            if (!remoteFrameBuffer) {
                remoteFrameBuffer = new Array(remoteFrameWidth * remoteFrameHeight).fill(0.5);
            }
            
            // Decode phase bits
            const changeCount = (bits & 0x07) * 10;        // Lower 3 bits
            const avgDelta = ((bits >> 3) & 0x07) / 7.0;   // Middle 3 bits
            const dirBits = (bits >> 6) & 0x03;            // Upper 2 bits
            const moveRight = (dirBits & 0x01) !== 0;
            const moveDown = (dirBits & 0x02) !== 0;
            
            // Motion vectors
            const dx = moveRight ? 1 : -1;
            const dy = moveDown ? 1 : -1;
            
            // Apply temporal smoothing with motion
            const newBuffer = new Array(remoteFrameBuffer.length);
            
            for (let y = 0; y < remoteFrameHeight; y++) {
                for (let x = 0; x < remoteFrameWidth; x++) {
                    const idx = y * remoteFrameWidth + x;
                    
                    // Motion compensation
                    const srcX = Math.min(Math.max(0, x - dx), remoteFrameWidth - 1);
                    const srcY = Math.min(Math.max(0, y - dy), remoteFrameHeight - 1);
                    const srcIdx = srcY * remoteFrameWidth + srcX;
                    
                    const motionBlend = remoteFrameBuffer[srcIdx];
                    
                    // Phase-based variation
                    const phaseVariation = Math.sin((x + y) * 0.1 + bits * 0.05) * avgDelta * 0.3;
                    
                    // Temporal smoothing
                    let newValue = remoteFrameBuffer[idx] * 0.7 + motionBlend * 0.2 + phaseVariation * 0.1 + 0.5;
                    newBuffer[idx] = Math.max(0, Math.min(1, newValue));
                }
            }
            
            // Add activity hotspots
            if (changeCount > 0) {
                const centerX = moveRight ? remoteFrameWidth * 3 / 4 : remoteFrameWidth / 4;
                const centerY = moveDown ? remoteFrameHeight * 3 / 4 : remoteFrameHeight / 4;
                const radius = Math.min(40, changeCount * 2);
                
                for (let y = Math.max(0, Math.floor(centerY - radius)); y < Math.min(remoteFrameHeight, Math.floor(centerY + radius)); y++) {
                    for (let x = Math.max(0, Math.floor(centerX - radius)); x < Math.min(remoteFrameWidth, Math.floor(centerX + radius)); x++) {
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        if (dist < radius) {
                            const idx = y * remoteFrameWidth + x;
                            const intensity = (1.0 - dist / radius) * avgDelta * 0.5;
                            newBuffer[idx] = Math.min(1.0, newBuffer[idx] + intensity);
                        }
                    }
                }
            }
            
            remoteFrameBuffer = newBuffer;
        }
        
        // ğŸ”¥ Phase-based video reconstruction (fallback - legacy)
        let remoteBuffer = null;
        
        function reconstructRemoteVideo(bits, data) {
            const remoteVideo = document.getElementById('remoteVideo');
            
            // Create canvas for reconstruction if needed
            if (!remoteCanvas) {
                remoteCanvas = document.createElement('canvas');
                remoteCanvas.width = 160;
                remoteCanvas.height = 120;
                remoteCtx = remoteCanvas.getContext('2d');
                remoteBuffer = remoteCtx.createImageData(160, 120);
                
                // Initialize with gray
                for (let i = 0; i < remoteBuffer.data.length; i += 4) {
                    remoteBuffer.data[i] = 80;     // R
                    remoteBuffer.data[i + 1] = 80; // G
                    remoteBuffer.data[i + 2] = 100; // B
                    remoteBuffer.data[i + 3] = 255; // A
                }
            }
            
            // Decode phase bits
            const changeCount = (bits & 0x07) * 10;
            const avgDelta = ((bits >> 3) & 0x07) / 70.0;
            const dirBits = (bits >> 6) & 0x03;
            const moveRight = (dirBits & 0x01) !== 0;
            const moveDown = (dirBits & 0x02) !== 0;
            
            // Apply phase-based changes
            const width = 160;
            const height = 120;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Motion compensation
                    const dx = moveRight ? 1 : -1;
                    const dy = moveDown ? 1 : -1;
                    const srcX = Math.min(Math.max(0, x - dx), width - 1);
                    const srcY = Math.min(Math.max(0, y - dy), height - 1);
                    const srcIdx = (srcY * width + srcX) * 4;
                    
                    // Temporal blend with motion
                    const prevR = remoteBuffer.data[srcIdx];
                    const prevG = remoteBuffer.data[srcIdx + 1];
                    const prevB = remoteBuffer.data[srcIdx + 2];
                    
                    // Phase-based variation
                    const phaseVar = Math.sin((x + y) * 0.1 + bits * 0.05) * avgDelta * 30;
                    
                    // Update with temporal smoothing
                    remoteBuffer.data[idx] = Math.min(255, Math.max(0, prevR * 0.9 + phaseVar + 50));
                    remoteBuffer.data[idx + 1] = Math.min(255, Math.max(0, prevG * 0.9 + phaseVar + 80));
                    remoteBuffer.data[idx + 2] = Math.min(255, Math.max(0, prevB * 0.9 + phaseVar + 100));
                }
            }
            
            // Add activity hotspot
            if (changeCount > 0) {
                const centerX = moveRight ? width * 3 / 4 : width / 4;
                const centerY = moveDown ? height * 3 / 4 : height / 4;
                const radius = Math.min(30, changeCount);
                
                for (let y = Math.max(0, centerY - radius); y < Math.min(height, centerY + radius); y++) {
                    for (let x = Math.max(0, centerX - radius); x < Math.min(width, centerX + radius); x++) {
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        if (dist < radius) {
                            const idx = (y * width + x) * 4;
                            const intensity = (1.0 - dist / radius) * avgDelta * 50;
                            remoteBuffer.data[idx] = Math.min(255, remoteBuffer.data[idx] + intensity);
                            remoteBuffer.data[idx + 1] = Math.min(255, remoteBuffer.data[idx + 1] + intensity * 0.8);
                            remoteBuffer.data[idx + 2] = Math.min(255, remoteBuffer.data[idx + 2] + intensity * 1.2);
                        }
                    }
                }
            }
            
            // Draw to canvas
            remoteCtx.putImageData(remoteBuffer, 0, 0);
            
            // Display on remote video element
            if (!remoteVideo.srcObject) {
                const stream = remoteCanvas.captureStream(30);
                remoteVideo.srcObject = stream;
            }
            
            lastRemotePhase = bits;
        }
        
        // ========================================
        // Call Controls
        // ========================================
        
        async function endCall() {
            const endPacket = new Î”Packet('call_end', {
                call_id: currentCallId,
                duration: callStartTime ? (Date.now() - callStartTime) / 1000 : 0
            });
            
            if (currentCallId) {
                try {
                    await fetch(`${SERVER_URL}/v1/call/end`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            call_id: currentCallId,
                            user_id: myDeltaId
                        })
                    });
                    sendPacket(endPacket);
                } catch (error) {
                    console.error('End call failed:', error);
                }
            }
            
            // Stop video
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Stop timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
            
            document.getElementById('videoContainer').classList.remove('active');
            resetCallUI();
        }
        
        function cancelCall() {
            endCall();
        }
        
        function resetCallUI() {
            currentCallId = null;
            document.getElementById('callInput').style.display = 'block';
            document.getElementById('callInput').innerHTML = `
                <h3>ğŸ“ ×”×ª×§×©×¨ ×“×¨×š Î”Network</h3>
                <div class="input-group">
                    <input type="text" id="targetDeltaId" placeholder="×”×›× ×¡ Î”ID ×©×œ ××™ ×©×¨×•×¦×™× ×œ×”×ª×§×©×¨...">
                    <button class="btn btn-call" onclick="startCall()">
                        ğŸ“ Î”Call
                    </button>
                </div>
            `;
            document.getElementById('incomingCall').style.display = 'none';
        }
        
        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('muteBtn').textContent = audioTrack.enabled ? 'ğŸ¤' : 'ğŸ”‡';
            }
        }
        
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('videoBtn').textContent = videoTrack.enabled ? 'ğŸ“¹' : 'ğŸ“·';
            }
        }
        
        // ========================================
        // Packet Logging
        // ========================================
        
        function logPacket(direction, context, data) {
            const entries = document.getElementById('packetEntries');
            const entry = document.createElement('div');
            entry.className = `packet-entry ${direction}`;
            
            const time = new Date().toLocaleTimeString('he-IL');
            const arrow = direction === 'tx' ? 'â†’' : 'â†';
            
            entry.textContent = `${time} ${arrow} ${context}`;
            entries.insertBefore(entry, entries.firstChild);
            
            // Keep only last 20 entries
            while (entries.children.length > 20) {
                entries.removeChild(entries.lastChild);
            }
        }
        
        // ========================================
        // Status Update
        // ========================================
        
        function updateStatus(text, type) {
            const el = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            statusText.textContent = text;
            el.className = `connection-status ${type}`;
        }
        
        function hideIncomingCall() {
            document.getElementById('incomingCall').style.display = 'none';
        }
        
        function showCallActive() {
            document.getElementById('videoContainer').classList.add('active');
            document.getElementById('callInput').style.display = 'none';
            callStartTime = Date.now();
            callTimer = setInterval(updateCallDuration, 1000);
        }
        
        // ========================================
        // Initialize - Î”CLOUD + P2P!
        // ========================================
        
        initDeltaId();
        
        // ğŸ”¥ğŸ’âš¡ Connect based on protocol! âš¡ğŸ’ğŸ”¥
        console.log('ğŸŒ Connecting to Î”CLOUD...');
        console.log('   Server:', SERVER_URL);
        console.log('   WebSocket:', WS_URL);
        console.log('   Can use WebSocket:', canUseWebSocket);
        
        // Only connect WebSocket if allowed (not HTTPS to HTTP)
        if (canUseWebSocket) {
            console.log('ğŸ”Œ Connecting WebSocket to Î”CLOUD...');
            connectWebSocket();
        } else {
            console.log('ğŸ”’ HTTPS mode - using PeerJS only (no WebSocket to HTTP server)');
            console.log('   PeerJS handles all P2P signaling!');
            updateStatus('××—×•×‘×¨ ×œ×¨×©×ª Î” (P2P)', 'connected');
        }
        
        // Subscribe to FieldBus events
        fieldBus.subscribe('all', (packet) => {
            console.log('FieldBus:', packet);
        });
    </script>
</body>
</html>
