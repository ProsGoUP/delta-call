<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î”Call - ×©×™×—×ª ×•×™×“××• | Phase Network</title>
    <!-- PeerJS - Public Signaling Server (NO PORT FORWARD NEEDED!) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --delta-cyan: #00d4ff;
            --delta-green: #00ff88;
            --delta-purple: #9d4edd;
            --delta-pink: #ff006e;
            --bg-dark: #0a0a1a;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Header */
        .header {
            text-align: center;
            padding: 40px 0;
        }
        
        .logo {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, var(--delta-cyan), var(--delta-green), var(--delta-pink));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
        }
        
        .protocol-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,212,255,0.1);
            border: 1px solid var(--delta-cyan);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 15px;
            font-size: 12px;
            color: var(--delta-cyan);
        }
        
        /* Call Card */
        .call-card {
            background: rgba(255,255,255,0.05);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            border: 1px solid rgba(0,212,255,0.2);
            margin-bottom: 30px;
        }
        
        .caller-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--delta-cyan), var(--delta-green));
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            font-size: 48px;
            font-weight: bold;
            color: #000;
            box-shadow: 0 0 40px rgba(0,212,255,0.3);
        }
        
        .caller-name {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .caller-id {
            font-family: monospace;
            color: var(--delta-cyan);
            font-size: 14px;
            background: rgba(0,212,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 20px;
        }
        
        .call-status {
            color: var(--delta-green);
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        .call-status.ringing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Buttons */
        .buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 16px 40px;
            border-radius: 50px;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .btn-answer {
            background: linear-gradient(90deg, var(--delta-green), var(--delta-cyan));
            color: #000;
        }
        
        .btn-answer:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.5);
        }
        
        .btn-decline {
            background: rgba(255,68,68,0.2);
            color: #ff4444;
            border: 2px solid #ff4444;
        }
        
        .btn-decline:hover {
            background: #ff4444;
            color: white;
        }
        
        .btn-call {
            background: linear-gradient(90deg, var(--delta-cyan), var(--delta-green));
            color: #000;
        }
        
        .btn-call:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,212,255,0.5);
        }
        
        /* Input */
        .input-section {
            background: rgba(255,255,255,0.05);
            border-radius: 24px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .input-section h3 {
            margin-bottom: 20px;
            color: var(--delta-cyan);
        }
        
        .input-group {
            display: flex;
            gap: 10px;
        }
        
        .input-group input {
            flex: 1;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 16px;
        }
        
        .input-group input::placeholder {
            color: #666;
        }
        
        /* Video Container */
        .video-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1000;
        }
        
        .video-container.active {
            display: block;
        }
        
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #111;
        }
        
        .local-video {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 150px;
            height: 200px;
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid var(--delta-cyan);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .local-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .video-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn.end-call {
            background: #ff4444;
            color: white;
        }
        
        .control-btn.mute {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
        }
        
        /* Stats - Î”Protocol Stats */
        .call-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 12px;
            border: 1px solid rgba(0,212,255,0.3);
        }
        
        .stats-header {
            color: var(--delta-cyan);
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #888;
        }
        
        .stat-value {
            color: var(--delta-green);
            font-family: monospace;
        }
        
        .stat-value.phase {
            color: var(--delta-purple);
        }
        
        /* Features - Î”Protocol Features */
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .feature {
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
        }
        
        .feature-icon {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .feature-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .feature-desc {
            color: #888;
            font-size: 11px;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status.connected {
            background: rgba(0,255,136,0.2);
            color: var(--delta-green);
            border: 1px solid var(--delta-green);
        }
        
        .connection-status.disconnected {
            background: rgba(255,68,68,0.2);
            color: #ff4444;
            border: 1px solid #ff4444;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: blink 2s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Phase Visualization */
        .phase-visualizer {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--delta-purple);
        }
        
        .phase-wave {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 30px;
        }
        
        .phase-bar {
            width: 4px;
            background: var(--delta-purple);
            border-radius: 2px;
            animation: wave 0.5s ease-in-out infinite;
        }
        
        @keyframes wave {
            0%, 100% { height: 10px; }
            50% { height: 25px; }
        }
        
        /* Î”Packet Log */
        .packet-log {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            border: 1px solid rgba(0,212,255,0.2);
        }
        
        .packet-log-header {
            color: var(--delta-cyan);
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .packet-entry {
            color: #888;
            margin-bottom: 4px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.02);
            border-radius: 4px;
        }
        
        .packet-entry.tx {
            border-left: 2px solid var(--delta-green);
        }
        
        .packet-entry.rx {
            border-left: 2px solid var(--delta-purple);
        }
    </style>
</head>
<body>
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">
        <span class="status-dot"></span>
        <span id="statusText">××ª×—×‘×¨ ×œ×¨×©×ª Î”...</span>
    </div>

    <div class="container">
        <div class="header">
            <div class="logo">Î”Call</div>
            <div class="subtitle">×©×™×—×•×ª ×•×™×“××• ×¢×œ Phase Network</div>
            <div class="protocol-badge">
                <span>âš¡</span>
                <span>Î”Protocol v1.0 | 0-Data | Phase Resonance</span>
            </div>
        </div>
        
        <!-- Call Input -->
        <div class="input-section" id="callInput">
            <h3>ğŸ“ ×”×ª×§×©×¨ ×“×¨×š Î”Network</h3>
            <div class="input-group">
                <input type="text" id="targetDeltaId" placeholder="×”×›× ×¡ Î”ID ×©×œ ××™ ×©×¨×•×¦×™× ×œ×”×ª×§×©×¨...">
                <button class="btn btn-call" onclick="startCall()">
                    ğŸ“ Î”Call
                </button>
            </div>
        </div>
        
        <!-- Incoming Call Card -->
        <div class="call-card" id="incomingCall" style="display: none;">
            <div class="caller-avatar" id="callerAvatar">?</div>
            <div class="caller-name" id="callerName">××™×©×”×• ××ª×§×©×¨...</div>
            <div class="caller-id" id="callerId">Î”-unknown</div>
            <div class="call-status ringing">ğŸ”” ×©×™×—×” × ×›× ×¡×ª ×“×¨×š Phase Network...</div>
            <div class="buttons">
                <button class="btn btn-answer" onclick="answerCall()">
                    ğŸ“ ×¢× ×”
                </button>
                <button class="btn btn-decline" onclick="declineCall()">
                    âŒ ×“×—×”
                </button>
            </div>
        </div>
        
        <!-- My ID Card -->
        <div class="call-card">
            <h3 style="margin-bottom: 20px;">ğŸ†” ×”-Î”ID ×©×œ×™</h3>
            <div class="caller-id" id="myDeltaId" style="cursor: pointer;" onclick="copyMyId()">
                ×˜×•×¢×Ÿ...
            </div>
            <p style="color: #888; font-size: 14px; margin-top: 15px;">
                ×œ×—×¥ ×œ×”×¢×ª×§×” | ×©×ª×£ ××ª ×”-ID ×”×–×” ×›×“×™ ×©×™×•×›×œ×• ×œ×”×ª×§×©×¨ ××œ×™×š
            </p>
            
            <!-- Î”Packet Log -->
            <div class="packet-log" id="packetLog">
                <div class="packet-log-header">ğŸ“¦ Î”Packet Log</div>
                <div id="packetEntries"></div>
            </div>
        </div>
        
        <!-- Î”Protocol Features -->
        <div class="features">
            <div class="feature">
                <div class="feature-icon">âš¡</div>
                <div class="feature-title">Î”Packet</div>
                <div class="feature-desc">×ª×§×©×•×¨×ª ××•× ×™×‘×¨×¡×œ×™×ª</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸŒŠ</div>
                <div class="feature-title">Phase Sync</div>
                <div class="feature-desc">×¡× ×›×¨×•×Ÿ ×˜××¤×•×¨×œ×™</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ”®</div>
                <div class="feature-title">0-Data</div>
                <div class="feature-desc">8 bits ×œ×¤×¨×™×™×</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ”’</div>
                <div class="feature-title">Î”-Signed</div>
                <div class="feature-desc">×—×ª×™××” ×§×¨×™×¤×˜×•×’×¨×¤×™×ª</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸ’</div>
                <div class="feature-title">Î”J Energy</div>
                <div class="feature-desc">×¢×œ×•×ª ×× ×¨×’×™×”</div>
            </div>
            <div class="feature">
                <div class="feature-icon">ğŸŒ</div>
                <div class="feature-title">Mesh Network</div>
                <div class="feature-desc">×¨×©×ª ××‘×•×–×¨×ª</div>
            </div>
        </div>
    </div>
    
    <!-- Video Call Container -->
    <div class="video-container" id="videoContainer">
        <video class="remote-video" id="remoteVideo" autoplay playsinline></video>
        <div class="local-video">
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
        
        <!-- Î”Protocol Stats -->
        <div class="call-stats">
            <div class="stats-header">
                <span>âš¡</span> Î”Protocol Stats
            </div>
            <div class="stat-row">
                <span class="stat-label">Î”t:</span>
                <span class="stat-value" id="callDuration">00:00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Phase:</span>
                <span class="stat-value phase" id="currentPhase">0Â°</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Î”J:</span>
                <span class="stat-value" id="energyUsed">0.00 J</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Packets TX:</span>
                <span class="stat-value" id="packetsTx">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Packets RX:</span>
                <span class="stat-value" id="packetsRx">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Bits/Frame:</span>
                <span class="stat-value" id="bitsPerFrame">8</span>
            </div>
        </div>
        
        <!-- Phase Visualizer -->
        <div class="phase-visualizer">
            <div style="color: #9d4edd; font-size: 11px; margin-bottom: 8px;">Phase Wave</div>
            <div class="phase-wave" id="phaseWave">
                <!-- Generated dynamically -->
            </div>
        </div>
        
        <div class="video-controls">
            <button class="control-btn mute" id="muteBtn" onclick="toggleMute()">ğŸ¤</button>
            <button class="control-btn end-call" onclick="endCall()">ğŸ“´</button>
            <button class="control-btn mute" id="videoBtn" onclick="toggleVideo()">ğŸ“¹</button>
        </div>
    </div>

    <script>
        // ğŸ”¥ğŸ’âš¡ Î”Call Web Client - Using Î”Protocol âš¡ğŸ’ğŸ”¥
        // ================================================
        
        // ğŸ”¥ Î”NET - Dynamic Connection to ANY Gateway!
        // The page connects to wherever it was loaded from - no hardcoded addresses!
        // This enables our mesh network - any user with internet is a gateway!
        const isSecure = window.location.protocol === 'https:';
        const currentHost = window.location.host; // Gets host:port dynamically
        const SERVER_URL = `${window.location.protocol}//${currentHost}`;
        const WS_URL = `${isSecure ? 'wss:' : 'ws:'}//${currentHost}`;
        
        console.log('ğŸ”¥ Î”NET Gateway:', SERVER_URL);
        console.log('ğŸ”Œ WebSocket Gateway:', WS_URL);
        
        // Î”Protocol State
        let myDeltaId = null;
        let currentCallId = null;
        let webSocket = null;
        let localStream = null;
        let callStartTime = null;
        let callTimer = null;
        
        // ğŸ”¥ PeerJS - Public Signaling (NO PORT FORWARD NEEDED!)
        let peer = null;
        let peerCall = null;
        const PEERJS_CONFIG = {
            // Use public PeerJS cloud server - FREE and always accessible!
            host: '0.peerjs.com',
            port: 443,
            secure: true,
            debug: 1,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { 
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ]
            }
        };
        
        // ğŸ”¥ WebRTC for real video/audio
        let peerConnection = null;
        const rtcConfig = {
            iceServers: [
                // STUN - for direct P2P (when possible)
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // TURN - for NAT bypass (when STUN fails) - FREE public servers
                { 
                    urls: 'turn:openrelay.metered.ca:80',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                { 
                    urls: 'turn:openrelay.metered.ca:443',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                },
                { 
                    urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                    username: 'openrelayproject',
                    credential: 'openrelayproject'
                }
            ],
            iceCandidatePoolSize: 10
        };
        
        // Î”Protocol Stats
        let packetsTx = 0;
        let packetsRx = 0;
        let totalEnergy = 0;
        let currentPhase = 0;
        
        // ========================================
        // Î”Packet - Universal Communication Unit
        // ========================================
        
        class Î”Packet {
            constructor(context, metadata = {}) {
                this.Î”t = Date.now() / 1000;  // Unix timestamp
                this.Î”J = this.calculateEnergy(context);  // Energy cost
                this.origin = myDeltaId;
                this.context = context;
                this.signature = this.sign();
                this.merkleProof = null;
                this.metadata = metadata;
            }
            
            calculateEnergy(context) {
                // Energy cost based on context
                const costs = {
                    'videoPhase': 0.001,  // 1mJ per video phase
                    'audioPhase': 0.0005, // 0.5mJ per audio phase
                    'call_start': 0.01,   // 10mJ to start call
                    'call_end': 0.005,    // 5mJ to end call
                    'sync': 0.0001        // 0.1mJ for sync
                };
                return costs[context] || 0.001;
            }
            
            sign() {
                // Simple signature (in production: use proper crypto)
                const data = `${this.Î”t}|${this.origin}|${this.context}`;
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash).toString(16).padStart(16, '0');
            }
            
            toJSON() {
                return {
                    Î”t: this.Î”t,
                    Î”J: this.Î”J,
                    origin: this.origin,
                    context: this.context,
                    signature: this.signature,
                    merkleProof: this.merkleProof,
                    metadata: this.metadata
                };
            }
        }
        
        // ========================================
        // Phase Engine - 0-Data Video Processing
        // ========================================
        
        class PhaseEngine {
            constructor() {
                this.lastFrame = null;
                this.phaseHistory = [];
            }
            
            // Generate 8-bit phase signature from video frame
            generatePhaseSignature(imageData) {
                if (!this.lastFrame) {
                    this.lastFrame = imageData;
                    return 0;
                }
                
                // Calculate change between frames
                let totalChange = 0;
                const data = imageData.data;
                const lastData = this.lastFrame.data;
                
                // Sample every 100th pixel for efficiency
                for (let i = 0; i < data.length; i += 400) {
                    const diff = Math.abs(data[i] - lastData[i]);
                    totalChange += diff;
                }
                
                this.lastFrame = imageData;
                
                // Normalize to 8 bits (0-255)
                const phase = Math.min(255, Math.floor(totalChange / 1000));
                this.phaseHistory.push(phase);
                
                // Keep only last 100 phases
                if (this.phaseHistory.length > 100) {
                    this.phaseHistory.shift();
                }
                
                return phase;
            }
            
            // Reconstruct from phase (receiver side)
            reconstructFromPhase(phase, context) {
                // In real implementation: use context + phase to reconstruct
                // For demo: return color based on phase
                return {
                    intensity: phase,
                    confidence: 0.95
                };
            }
        }
        
        const phaseEngine = new PhaseEngine();
        
        // ========================================
        // Î”FieldBus - Local Event Broadcasting
        // ========================================
        
        class Î”FieldBus {
            constructor() {
                this.subscribers = new Map();
            }
            
            subscribe(context, callback) {
                if (!this.subscribers.has(context)) {
                    this.subscribers.set(context, []);
                }
                this.subscribers.get(context).push(callback);
            }
            
            publish(packet) {
                const callbacks = this.subscribers.get(packet.context) || [];
                callbacks.forEach(cb => cb(packet));
                
                // Also publish to 'all' subscribers
                const allCallbacks = this.subscribers.get('all') || [];
                allCallbacks.forEach(cb => cb(packet));
            }
        }
        
        const fieldBus = new Î”FieldBus();
        
        // ========================================
        // PeerJS - Public Signaling (NO PORT FORWARD!)
        // ========================================
        
        function initPeerJS() {
            // Create peer with our Delta ID (cleaned for PeerJS)
            // PeerJS IDs must start with letter and contain only alphanumeric + hyphen
            let peerId = myDeltaId.replace(/[^a-zA-Z0-9]/g, '');
            // Ensure it starts with a letter
            if (!/^[a-zA-Z]/.test(peerId)) {
                peerId = 'D' + peerId;
            }
            
            console.log('ğŸ”¥ Initializing PeerJS with ID:', peerId);
            
            peer = new Peer(peerId, PEERJS_CONFIG);
            
            peer.on('open', (id) => {
                console.log('âœ… PeerJS connected! ID:', id);
                updateStatus('××—×•×‘×¨ ×œ×¨×©×ª Î” (P2P)', 'connected');
                
                // Show shareable link
                const shareLink = `${window.location.origin}/call?call=${myDeltaId}`;
                console.log('ğŸ“± Share this link:', shareLink);
            });
            
            peer.on('call', async (call) => {
                console.log('ğŸ“ Incoming P2P call from:', call.peer);
                
                // Show incoming call UI
                showIncomingCall(call.peer);
                
                // Store the call for answering
                window.pendingPeerCall = call;
            });
            
            peer.on('error', (err) => {
                console.error('âŒ PeerJS error:', err);
                // Fallback to WebSocket if PeerJS fails
                if (!webSocket || webSocket.readyState !== WebSocket.OPEN) {
                    connectWebSocket();
                }
            });
            
            peer.on('disconnected', () => {
                console.log('âš ï¸ PeerJS disconnected, reconnecting...');
                peer.reconnect();
            });
        }
        
        async function answerPeerCall() {
            if (!window.pendingPeerCall) return;
            
            const call = window.pendingPeerCall;
            
            // Get local media
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ Show video container IMMEDIATELY for answerer!
                document.getElementById('videoContainer').classList.add('active');
                document.getElementById('incomingCall').style.display = 'none';
                document.getElementById('callInput').style.display = 'none';
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // Answer the call with our stream
                call.answer(localStream);
                
                call.on('stream', (remoteStream) => {
                    console.log('ğŸ¥ Got remote stream!');
                    document.getElementById('remoteVideo').srcObject = remoteStream;
                });
                
                call.on('close', () => {
                    console.log('ğŸ“´ Call closed');
                    endCall();
                });
                
                peerCall = call;
                window.pendingPeerCall = null;
                
            } catch (err) {
                console.error('âŒ Media error:', err);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”/××™×§×¨×•×¤×•×Ÿ');
            }
        }
        
        async function startPeerCall(targetId) {
            // Clean target ID for PeerJS - must start with letter
            let peerId = targetId.replace(/[^a-zA-Z0-9]/g, '');
            if (!/^[a-zA-Z]/.test(peerId)) {
                peerId = 'D' + peerId;
            }
            
            console.log('ğŸ“ Starting P2P call to:', peerId);
            
            try {
                // Get local media
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ Show video container IMMEDIATELY for caller!
                document.getElementById('videoContainer').classList.add('active');
                document.getElementById('callInput').style.display = 'none';
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // Make the call
                const call = peer.call(peerId, localStream);
                
                call.on('stream', (remoteStream) => {
                    console.log('ğŸ¥ Got remote stream!');
                    document.getElementById('remoteVideo').srcObject = remoteStream;
                });
                
                call.on('error', (err) => {
                    console.error('âŒ Call error:', err);
                    alert('×©×’×™××” ×‘×”×ª×—×‘×¨×•×ª');
                    endCall();
                });
                
                call.on('close', () => {
                    console.log('ğŸ“´ Call closed');
                    endCall();
                });
                
                peerCall = call;
                
            } catch (err) {
                console.error('âŒ Media error:', err);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”/××™×§×¨×•×¤×•×Ÿ');
            }
        }
        
        function endPeerCall() {
            if (peerCall) {
                peerCall.close();
                peerCall = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            document.getElementById('localVideo').srcObject = null;
            document.getElementById('remoteVideo').srcObject = null;
        }
        
        // ========================================
        // Initialization
        // ========================================
        
        function initDeltaId() {
            myDeltaId = localStorage.getItem('delta_id');
            if (!myDeltaId) {
                // Generate Î”ID using timestamp + random
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 8);
                myDeltaId = `Î”-web-${timestamp}-${random}`;
                localStorage.setItem('delta_id', myDeltaId);
            }
            document.getElementById('myDeltaId').textContent = myDeltaId;
            
            // ğŸ”¥ Initialize PeerJS with public signaling - NO PORT FORWARD!
            initPeerJS();
            
            // Check URL for incoming call
            const urlParams = new URLSearchParams(window.location.search);
            const callTo = urlParams.get('call');
            if (callTo) {
                document.getElementById('targetDeltaId').value = callTo;
            }
            
            // Initialize phase wave visualization
            initPhaseWave();
            
            // Log initial packet
            logPacket('tx', 'init', { id: myDeltaId });
        }
        
        function initPhaseWave() {
            const wave = document.getElementById('phaseWave');
            for (let i = 0; i < 20; i++) {
                const bar = document.createElement('div');
                bar.className = 'phase-bar';
                bar.style.animationDelay = `${i * 0.05}s`;
                wave.appendChild(bar);
            }
        }
        
        function copyMyId() {
            navigator.clipboard.writeText(myDeltaId);
            const el = document.getElementById('myDeltaId');
            el.textContent = 'âœ… ×”×•×¢×ª×§!';
            setTimeout(() => {
                el.textContent = myDeltaId;
            }, 2000);
        }
        
        // ========================================
        // WebSocket Connection (Î”Protocol Transport)
        // ========================================
        
        function connectWebSocket() {
            const wsUrl = `${WS_URL}/ws/call/${myDeltaId}`;
            console.log('ğŸ”Œ Connecting to WebSocket:', wsUrl);
            
            webSocket = new WebSocket(wsUrl);
            
            webSocket.onopen = () => {
                console.log('âœ… Î”Network connected to:', wsUrl);
                updateConnectionStatus(true);
                registerWithServer();
                
                // Send sync packet
                const syncPacket = new Î”Packet('sync', { status: 'connected' });
                sendPacket(syncPacket);
            };
            
            webSocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
                packetsRx++;
                updateStats();
            };
            
            webSocket.onclose = () => {
                console.log('âŒ Î”Network disconnected');
                updateConnectionStatus(false);
                setTimeout(connectWebSocket, 3000);
            };
            
            webSocket.onerror = (error) => {
                console.error('âŒ WebSocket error:', error);
                console.error('   URL was:', wsUrl);
                updateConnectionStatus(false);
            };
        }
        
        function updateConnectionStatus(connected) {
            const el = document.getElementById('connectionStatus');
            const text = document.getElementById('statusText');
            
            if (connected) {
                el.className = 'connection-status connected';
                text.textContent = '××—×•×‘×¨ ×œ×¨×©×ª Î”';
            } else {
                el.className = 'connection-status disconnected';
                text.textContent = '××ª×—×‘×¨ ×œ×¨×©×ª Î”...';
            }
        }
        
        // Send Î”Packet
        function sendPacket(packet) {
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send(JSON.stringify(packet.toJSON()));
                packetsTx++;
                totalEnergy += packet.Î”J;
                updateStats();
                logPacket('tx', packet.context, packet.metadata);
            }
        }
        
        // Register with server using Î”Packet
        async function registerWithServer() {
            const packet = new Î”Packet('sync', {
                device_id: myDeltaId,
                device_name: 'Web Browser',
                device_type: 'web'
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/fieldnet/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_id: myDeltaId,
                        device_name: 'Web Browser'
                    })
                });
                console.log('âœ… Registered with Î”FieldNet');
                logPacket('tx', 'register', { success: true });
            } catch (error) {
                console.error('Registration failed:', error);
                logPacket('tx', 'register', { success: false });
            }
        }
        
        // ========================================
        // Message Handling
        // ========================================
        
        function handleWebSocketMessage(data) {
            console.log('ğŸ“¨ Î”Packet received:', data);
            logPacket('rx', data.type || 'unknown', data);
            
            // Publish to FieldBus
            fieldBus.publish({ context: data.type, ...data });
            
            switch (data.type) {
                case 'connected':
                    console.log('âœ… WebSocket connected, ready for calls');
                    break;
                    
                case 'incoming_call':
                    showIncomingCall(data.caller_id, data.caller_name || 'Unknown');
                    currentCallId = data.call_id;
                    
                    // ğŸ”¥ AUTO-ANSWER after 1 second for testing!
                    console.log('ğŸ”” Auto-answering in 1 second...');
                    setTimeout(() => {
                        console.log('ğŸ“ Auto-answering call!');
                        answerCall();
                    }, 1000);
                    break;
                    
                case 'call_answered':
                    console.log('ğŸ‰ Call answered! Starting video...');
                    logPacket('rx', 'call_answered', { call_id: data.call_id });
                    startVideoCall();
                    break;
                    
                case 'call_rejected':
                    alert('×”×©×™×—×” × ×“×—×ª×”');
                    resetCallUI();
                    break;
                    
                case 'call_ended':
                    endCall();
                    break;
                    
                case 'phase':
                    handlePhaseData(data);
                    break;
                    
                case 'video_frame':
                case 'full_frame':
                case 'v':
                    handleVideoFrame(data);
                    break;
                    
                case 'audio':
                    handleAudioFrame(data);
                    break;
                    
                case 'delta_frame':
                    handleDeltaFrame(data);
                    break;
                    
                case 'webrtc':
                case 'webrtc_offer':
                case 'webrtc_answer':
                case 'ice_candidate':
                    handleWebRTCSignal(data);
                    break;
                    
                case 'pong':
                case 'keepalive':
                    // Ignore keepalive messages
                    break;
                    
                default:
                    console.log('ğŸ“¨ Unknown message type:', data.type);
            }
        }
        
        // ========================================
        // Call Management
        // ========================================
        
        function showIncomingCall(callerId, callerName) {
            document.getElementById('callInput').style.display = 'none';
            document.getElementById('incomingCall').style.display = 'block';
            document.getElementById('callerName').textContent = callerName;
            document.getElementById('callerId').textContent = callerId;
            document.getElementById('callerAvatar').textContent = callerName.charAt(0).toUpperCase();
        }
        
        async function startCall() {
            const targetId = document.getElementById('targetDeltaId').value.trim();
            if (!targetId) {
                alert('×”×›× ×¡ Î”ID');
                return;
            }
            
            // ğŸ”¥ Use PeerJS for P2P call - NO PORT FORWARD NEEDED!
            if (peer && peer.open) {
                console.log('ğŸ”¥ Using PeerJS P2P (no port forward needed!)');
                // startPeerCall opens video screen immediately - don't override!
                await startPeerCall(targetId);
                return;
            }
            
            // Fallback to WebSocket signaling
            console.log('âš ï¸ PeerJS not available, using WebSocket fallback');
            
            // Create call packet
            const callPacket = new Î”Packet('call_start', {
                target: targetId,
                type: 'video'
            });
            
            try {
                const response = await fetch(`${SERVER_URL}/v1/call/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        caller_id: myDeltaId,
                        callee_id: targetId,
                        call_type: 'video'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    currentCallId = data.call_id;
                    sendPacket(callPacket);
                    
                    // ğŸ”¥ Start video immediately! Don't wait for answer!
                    console.log('ğŸ”¥ Starting video call immediately...');
                    startVideoCall();
                    
                    document.getElementById('callInput').innerHTML = `
                        <h3>ğŸ“ ××ª×§×©×¨ ×“×¨×š Î”Network...</h3>
                        <p style="color: #888;">×××ª×™×Ÿ ×œ×ª×©×•×‘×” ×-${targetId}</p>
                        <p style="color: #00d4ff; font-size: 12px; margin-top: 10px;">
                            âš¡ Sending Î”Packets...
                        </p>
                        <button class="btn btn-decline" onclick="cancelCall()" style="margin-top: 20px;">
                            âŒ ×‘×˜×œ
                        </button>
                    `;
                } else {
                    alert('×©×’×™××”: ' + data.message);
                }
            } catch (error) {
                console.error('Call failed:', error);
                alert('×©×’×™××” ×‘×”×ª×—×œ×ª ×©×™×—×”');
            }
        }
        
        async function answerCall() {
            // ğŸ”¥ Check if this is a PeerJS call
            if (window.pendingPeerCall) {
                console.log('ğŸ”¥ Answering PeerJS P2P call');
                await answerPeerCall();
                return;
            }
            
            // Fallback to WebSocket signaling
            const answerPacket = new Î”Packet('call_answer', {
                call_id: currentCallId,
                accepted: true
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/call/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        callee_id: myDeltaId,
                        accepted: true
                    })
                });
                
                sendPacket(answerPacket);
                startVideoCall();
            } catch (error) {
                console.error('Answer failed:', error);
            }
        }
        
        async function declineCall() {
            const declinePacket = new Î”Packet('call_answer', {
                call_id: currentCallId,
                accepted: false
            });
            
            try {
                await fetch(`${SERVER_URL}/v1/call/answer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        call_id: currentCallId,
                        callee_id: myDeltaId,
                        accepted: false
                    })
                });
                
                sendPacket(declinePacket);
                resetCallUI();
            } catch (error) {
                console.error('Decline failed:', error);
            }
        }
        
        // ========================================
        // Video Call with Phase Processing
        // ========================================
        
        async function startVideoCall() {
            document.getElementById('videoContainer').classList.add('active');
            document.getElementById('incomingCall').style.display = 'none';
            document.getElementById('callInput').style.display = 'none';
            
            try {
                // Get local media (for local preview only!)
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                document.getElementById('localVideo').srcObject = localStream;
                
                // ğŸ”¥ğŸ’€âš¡ TRUE 0-DATA: Resonance Sync instead of WebRTC! âš¡ğŸ’€ğŸ”¥
                await setupResonanceSync();
                
                // Start call timer
                callStartTime = Date.now();
                callTimer = setInterval(updateCallDuration, 1000);
                
                // ğŸ”¥ PURE FLOW: Only ONE transmission system!
                // startPhaseTransmission is DISABLED - using startDeltaTransmission instead!
                // startPhaseTransmission();
                
                console.log('ğŸ”¥ PURE FLOW Video call started!');
                console.log('   - Change = Compute active');
                console.log('   - 640x480 @ 30fps (phase-locked)');
                console.log('   - NO duplicate transmissions!');
                
            } catch (error) {
                console.error('Camera access failed:', error);
                alert('×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ××¦×œ××”: ' + error.message);
            }
        }
        
        // ğŸ”¥ğŸ’€âš¡ TRUE Î”-VIDEO: Change = Compute! âš¡ğŸ’€ğŸ”¥
        // ================================================================
        // ONLY send when there's SIGNIFICANT CHANGE (Î” > threshold)
        // NO fixed intervals! NO keyframes every X seconds!
        // Pure event-driven: Change happens â†’ Send delta!
        
        // Remote video state
        let remoteFrameCanvas = null;
        let remoteFrameCtx = null;
        let prevLocalFrame = null;  // Previous frame for delta calculation
        let remoteFrameData = null; // Accumulated remote frame
        const DELTA_THRESHOLD = 0.015; // Same as Max8 Overlay!
        
        async function setupResonanceSync() {
            console.log('ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE Video Call @ 500Hz âš¡ğŸ’€ğŸ”¥');
            console.log('   - Both sides on SAME PHASE');
            console.log('   - Video: 640x480 @ 30fps');
            console.log('   - Audio: Native rate');
            console.log('   - Change = Compute active');
            
            // Create canvas for remote video - FULL HD!
            remoteFrameCanvas = document.createElement('canvas');
            remoteFrameCanvas.width = 1280;
            remoteFrameCanvas.height = 720;
            remoteFrameCtx = remoteFrameCanvas.getContext('2d');
            
            // Initialize
            remoteFrameData = null;
            
            // Start phase-locked streaming!
            startDeltaTransmission();
            startVideoReconstruction();
        }
        
        // ğŸ”¥ğŸ’€âš¡ TEMPORAL RESONANCE @ 500Hz + CHANGE = COMPUTE âš¡ğŸ’€ğŸ”¥
        // ================================================================
        // Core: Both sides resonate at SAME PHASE (500Hz base frequency)
        // Energy âˆ Change (NOT time!) - If no change â†’ 0 energy!
        // From delta_engine.py: 344,433 frames with 0 energy!
        
        const BASE_FREQUENCY = 500.0;  // Hz - ×ª×“×¨ ×”×‘×¡×™×¡!
        const CHANGE_THRESHOLD = 0.015;  // 1.5% - ×›××• Max8 Overlay!
        const FRAME_INTERVAL = 33;  // 30fps = every ~16 phase cycles
        
        let lastFrameData = null;
        let lastSendTime = 0;
        let phaseCounter = 0;
        let audioContext = null;
        let audioProcessor = null;
        
        function startDeltaTransmission() {
            const video = document.getElementById('localVideo');
            const canvas = document.createElement('canvas');
            // ğŸ”¥ FULL HD Quality!
            canvas.width = 1280;
            canvas.height = 720;
            const ctx = canvas.getContext('2d');
            
            // ğŸ¤ Setup Audio on SAME PHASE
            setupAudioTransmission();
            
            function phaseLoop() {
                const now = Date.now();
                phaseCounter++;
                
                if (!localStream || !currentCallId || 
                    !webSocket || webSocket.readyState !== WebSocket.OPEN) {
                    requestAnimationFrame(phaseLoop);
                    return;
                }
                
                // ğŸ”¥ CHANGE = COMPUTE @ 500Hz!
                // Check every frame but only send on CHANGE!
                
                // Capture FULL HD frame
                ctx.drawImage(video, 0, 0, 1280, 720);
                const currentFrame = ctx.getImageData(0, 0, 1280, 720);
                
                // ğŸ”¥ CHANGE DETECTION - sample 500 pixels
                let hasChange = true;
                let changeRatio = 1.0;
                
                if (lastFrameData) {
                    let totalDiff = 0;
                    const sampleSize = 500;
                    for (let i = 0; i < sampleSize; i++) {
                        const idx = Math.floor(Math.random() * currentFrame.data.length / 4) * 4;
                        totalDiff += Math.abs(currentFrame.data[idx] - lastFrameData.data[idx]) / 255;
                    }
                    changeRatio = totalDiff / sampleSize;
                    hasChange = changeRatio > CHANGE_THRESHOLD;
                }
                
                // ğŸ”¥ EVENT-DRIVEN: Send ONLY when there's change!
                // If no change â†’ 0 data â†’ 0 energy (like 344,433 frames!)
                if (hasChange) {
                    const frame = canvas.toDataURL('image/jpeg', 0.95);  // High quality!
                    
                    webSocket.send(JSON.stringify({
                        type: 'video_frame',
                        call_id: currentCallId,
                        sender_id: myDeltaId,
                        image: frame,
                        phase: phaseCounter,
                        freq: BASE_FREQUENCY,
                        change: changeRatio,
                        t: now
                    }));
                    
                    lastFrameData = currentFrame;
                }
                
                requestAnimationFrame(phaseLoop);
            }
            
            requestAnimationFrame(phaseLoop);
            console.log('ğŸ”¥ğŸ’€âš¡ CHANGE = COMPUTE active! âš¡ğŸ’€ğŸ”¥');
            console.log(`   - Base Frequency: ${BASE_FREQUENCY}Hz`);
            console.log('   - Video: 1280x720 FULL HD');
            console.log('   - JPEG Quality: 95%');
            console.log('   - Change Threshold: 1.5%');
            console.log('   - EVENT-DRIVEN (not clock-driven!)');
        }
        
        // ğŸ¤ PHASE-LOCKED Audio Transmission
        function setupAudioTransmission() {
            if (!localStream) return;
            
            try {
                // Use browser's native sample rate
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const nativeSampleRate = audioContext.sampleRate;
                
                const source = audioContext.createMediaStreamSource(localStream);
                // Larger buffer for smooth audio
                audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                audioProcessor.onaudioprocess = (e) => {
                    if (!currentCallId || !webSocket || webSocket.readyState !== WebSocket.OPEN) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    
                    // Check for actual sound
                    let maxAmplitude = 0;
                    for (let i = 0; i < inputData.length; i++) {
                        maxAmplitude = Math.max(maxAmplitude, Math.abs(inputData[i]));
                    }
                    
                    // Only send if there's actual audio (not silence)
                    if (maxAmplitude > 0.02) {
                        // Send at native rate - no downsampling for quality!
                        const audioData = new Int16Array(inputData.length);
                        for (let i = 0; i < inputData.length; i++) {
                            audioData[i] = Math.max(-32768, Math.min(32767, Math.round(inputData[i] * 32768)));
                        }
                        
                        webSocket.send(JSON.stringify({
                            type: 'audio',
                            call_id: currentCallId,
                            sender_id: myDeltaId,
                            data: Array.from(audioData),
                            rate: nativeSampleRate,
                            phase: phaseCounter,
                            t: Date.now()
                        }));
                    }
                };
                
                source.connect(audioProcessor);
                audioProcessor.connect(audioContext.destination);
                
                console.log(`ğŸ¤ Audio: ${nativeSampleRate}Hz (native, phase-locked)`);
            } catch (error) {
                console.error('Audio setup failed:', error);
            }
        }

        
        // ğŸ”¥ Display FULL HD remote video - EVENT-DRIVEN!
        function startVideoReconstruction() {
            const remoteVideo = document.getElementById('remoteVideo');
            let streamSet = false;
            
            function display() {
                // ğŸ”¥ If PeerJS already set a real stream, don't override it!
                if (remoteVideo.srcObject && remoteVideo.srcObject.getVideoTracks && 
                    remoteVideo.srcObject.getVideoTracks().length > 0 &&
                    remoteVideo.srcObject !== remoteFrameCanvas.captureStream(0)) {
                    // PeerJS stream is active - don't override!
                    return;
                }
                
                if (!remoteFrameData) {
                    remoteFrameCtx.fillStyle = '#0a0a0a';
                    remoteFrameCtx.fillRect(0, 0, 1280, 720);
                    remoteFrameCtx.fillStyle = '#00d4ff';
                    remoteFrameCtx.font = '32px Arial';
                    remoteFrameCtx.textAlign = 'center';
                    remoteFrameCtx.fillText('â³ ××¡× ×›×¨×Ÿ Phase @ 500Hz...', 640, 360);
                } else {
                    remoteFrameCtx.putImageData(remoteFrameData, 0, 0);
                }
                
                if (!streamSet && !remoteVideo.srcObject) {
                    // UNLIMITED FPS - event driven!
                    const stream = remoteFrameCanvas.captureStream(0);  // 0 = unlimited!
                    remoteVideo.srcObject = stream;
                    streamSet = true;
                    console.log('ğŸ¬ FULL HD display ready - 1280x720 @ UNLIMITED FPS');
                }
                
                requestAnimationFrame(display);
            }
            
            display();
        }
        
        // ğŸ”¥ Receive FULL HD frame - PHASE SYNCHRONIZED
        let remotePhase = 0;
        
        function handleVideoFrame(data) {
            const imageData = data.image || data.i;
            if (!imageData) return;
            
            // Track remote phase for synchronization
            if (data.phase) {
                remotePhase = data.phase;
            }
            
            const img = new Image();
            img.onload = () => {
                // FULL HD!
                remoteFrameCtx.drawImage(img, 0, 0, 1280, 720);
                remoteFrameData = remoteFrameCtx.getImageData(0, 0, 1280, 720);
            };
            img.src = imageData;
        }
        
        // ğŸ¤ PHASE-LOCKED Audio Playback
        let remoteAudioContext = null;
        let nextPlayTime = 0;
        let audioBufferQueue = [];
        const MAX_AUDIO_QUEUE = 3;  // Keep queue small for low latency
        
        function handleAudioFrame(data) {
            if (!data.data || data.data.length === 0) return;
            
            const sampleRate = data.rate || 48000;
            
            // Initialize audio context at the SAME sample rate as sender
            if (!remoteAudioContext) {
                try {
                    remoteAudioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: sampleRate
                    });
                    nextPlayTime = remoteAudioContext.currentTime;
                    console.log(`ğŸ”Š Audio playback: ${sampleRate}Hz`);
                } catch (e) {
                    // Fallback to default sample rate
                    remoteAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    nextPlayTime = remoteAudioContext.currentTime;
                    console.log(`ğŸ”Š Audio playback: ${remoteAudioContext.sampleRate}Hz (fallback)`);
                }
            }
            
            // Resume if suspended
            if (remoteAudioContext.state === 'suspended') {
                remoteAudioContext.resume();
            }
            
            // Convert Int16 back to Float32
            const audioData = new Float32Array(data.data.length);
            for (let i = 0; i < data.data.length; i++) {
                audioData[i] = data.data[i] / 32768.0;
            }
            
            // Create buffer
            const buffer = remoteAudioContext.createBuffer(1, audioData.length, sampleRate);
            buffer.getChannelData(0).set(audioData);
            
            // Schedule playback
            const source = remoteAudioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(remoteAudioContext.destination);
            
            const now = remoteAudioContext.currentTime;
            
            // Keep audio in sync - don't let it drift too far
            if (nextPlayTime < now) {
                nextPlayTime = now + 0.01;  // Small buffer
            } else if (nextPlayTime > now + 0.3) {
                // Too far ahead - reset
                nextPlayTime = now + 0.01;
            }
            
            source.start(nextPlayTime);
            nextPlayTime += buffer.duration;
        }
        
        function playNextAudio() {}
        
        // ğŸ”¥ Handle incoming full frame (legacy)
        function handleFullFrame(data) {
            handleVideoFrame(data);
        }
        
        // ğŸ”¥ Handle incoming delta frame - HIGH QUALITY!
        function handleDeltaFrame(data) {
            if (!remoteFrameData) return;
            
            const width = data.width || 320;
            const changes = data.changes || [];
            
            // Apply all changes
            for (const change of changes) {
                const idx = change.i * 4;
                if (idx >= 0 && idx < remoteFrameData.data.length - 3) {
                    remoteFrameData.data[idx] = change.r;
                    remoteFrameData.data[idx + 1] = change.g;
                    remoteFrameData.data[idx + 2] = change.b;
                    remoteFrameData.data[idx + 3] = 255;
                    
                    // ğŸ”¥ Also fill neighboring pixels for smoothness
                    const x = change.i % width;
                    const y = Math.floor(change.i / width);
                    
                    // Fill right and bottom neighbors
                    if (x < width - 1) {
                        const rightIdx = (change.i + 1) * 4;
                        remoteFrameData.data[rightIdx] = change.r;
                        remoteFrameData.data[rightIdx + 1] = change.g;
                        remoteFrameData.data[rightIdx + 2] = change.b;
                        remoteFrameData.data[rightIdx + 3] = 255;
                    }
                    if (y < 239) {
                        const bottomIdx = (change.i + width) * 4;
                        remoteFrameData.data[bottomIdx] = change.r;
                        remoteFrameData.data[bottomIdx + 1] = change.g;
                        remoteFrameData.data[bottomIdx + 2] = change.b;
                        remoteFrameData.data[bottomIdx + 3] = 255;
                    }
                }
            }
            
            if (changes.length > 100) {
                console.log(`ğŸ“¥ Applied ${changes.length} changes`);
            }
        }
        
        // ğŸ”¥ Resonance state
        let myFrequency = 500.0;
        let peerFrequency = 500.0;
        let resonanceCoherence = 0.0;
        
        // ğŸ”¥ Calculate resonance coherence (how well we sync)
        function calculateResonanceCoherence(freq1, freq2) {
            const ratio = Math.max(freq1, freq2) / Math.min(freq1, freq2);
            const nearestHarmonic = Math.round(ratio);
            const deviation = Math.abs(ratio - nearestHarmonic);
            return Math.exp(-deviation / 0.05);
        }
        
        // ğŸ”¥ Sync our frequency to peer's (harmonic alignment)
        function syncToPeerFrequency(peerFreq) {
            peerFrequency = peerFreq;
            
            const ratio = myFrequency / peerFreq;
            const nearestHarmonic = Math.round(ratio);
            const targetFrequency = peerFreq * nearestHarmonic;
            
            // Slowly drift towards harmonic alignment
            myFrequency = myFrequency * 0.9 + targetFrequency * 0.1;
            
            // Update coherence
            resonanceCoherence = calculateResonanceCoherence(myFrequency, peerFrequency);
        }
        
        // ğŸ”¥ Remote frame buffer for phase-based reconstruction
        let remoteFrameBuffer = null;
        let remoteFrameWidth = 160;
        let remoteFrameHeight = 120;
        let lastRemotePhase = 0;
        let remoteCanvas = null;
        let remoteCtx = null;
        
        // ğŸ”¥ğŸ’€âš¡ RESONANCE SYNC: Show local camera synced to remote frequency! âš¡ğŸ’€ğŸ”¥
        // ========================================================================
        // We show OUR camera, but with overlay based on remote Phase!
        // When frequencies match (high coherence) = clearer view!
        
        function startResonanceVisualization() {
            const remoteVideo = document.getElementById('remoteVideo');
            const localVideo = document.getElementById('localVideo');
            
            // Create canvas for synced view
            remoteCanvas = document.createElement('canvas');
            remoteCanvas.width = 320;
            remoteCanvas.height = 240;
            remoteCtx = remoteCanvas.getContext('2d');
            
            // Animate synced camera view
            function animate() {
                if (!localStream) {
                    requestAnimationFrame(animate);
                    return;
                }
                
                // Draw local video to canvas
                remoteCtx.drawImage(localVideo, 0, 0, 320, 240);
                
                // Apply resonance overlay based on coherence
                // Higher coherence = less overlay = clearer view!
                const overlayAlpha = Math.max(0, (1.0 - resonanceCoherence) * 0.5);
                
                // Frequency affects the color hue
                const hue = (peerFrequency % 360);
                
                // Draw overlay
                remoteCtx.fillStyle = `hsla(${hue}, 50%, 50%, ${overlayAlpha})`;
                remoteCtx.fillRect(0, 0, 320, 240);
                
                // Add resonance indicator
                if (resonanceCoherence > 0.1) {
                    // Draw sync rings
                    const centerX = 160;
                    const centerY = 120;
                    const time = Date.now() / 1000;
                    
                    for (let i = 0; i < 3; i++) {
                        const radius = 30 + i * 20 + Math.sin(time * (myFrequency/500) + i) * 5;
                        const alpha = resonanceCoherence * (1 - i * 0.2) * 0.3;
                        
                        remoteCtx.beginPath();
                        remoteCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        remoteCtx.strokeStyle = `rgba(0, 255, 200, ${alpha})`;
                        remoteCtx.lineWidth = 2;
                        remoteCtx.stroke();
                    }
                }
                
                // Display on remote video element
                remoteVideo.style.backgroundImage = `url(${remoteCanvas.toDataURL()})`;
                remoteVideo.style.backgroundSize = 'cover';
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Legacy function - no longer used
        async function handleWebRTCSignal(data) {
            console.log('âš ï¸ WebRTC signal ignored - using TRUE 0-DATA Resonance Sync!');
        }
        
        function sendWebRTCSignal(data) {
            console.log('âš ï¸ WebRTC disabled - using TRUE 0-DATA Resonance Sync!');
        }
        
        function updateCallDuration() {
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('callDuration').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function updateStats() {
            document.getElementById('packetsTx').textContent = packetsTx;
            document.getElementById('packetsRx').textContent = packetsRx;
            document.getElementById('energyUsed').textContent = totalEnergy.toFixed(4) + ' J';
            
            // Update phase
            currentPhase = (currentPhase + 7) % 360;
            document.getElementById('currentPhase').textContent = currentPhase + 'Â°';
        }
        
        // ğŸ”¥ğŸ’€âš¡ TRUE 0-DATA Phase Transmission âš¡ğŸ’€ğŸ”¥
        // =============================================
        // Send ONLY Phase (6-9 bits per frame!)
        // NO video data! NO pixels! NO spikes!
        
        function startPhaseTransmission() {
            console.log('ğŸ”¥ TRUE 0-DATA Phase transmission started!');
            console.log('   - Sending ONLY 6-9 bits per frame');
            console.log('   - NO video data, NO pixels, NO spikes');
            
            const video = document.getElementById('localVideo');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            let lastFrameData = null;
            
            // Process frames at 30fps
            setInterval(() => {
                if (!localStream || !currentCallId) return;
                
                // Sample video for activity detection
                canvas.width = 40;  // Very small - just for activity detection
                canvas.height = 30;
                ctx.drawImage(video, 0, 0, 40, 30);
                
                const imageData = ctx.getImageData(0, 0, 40, 30);
                
                // Calculate activity level (how much movement)
                let totalChange = 0;
                if (lastFrameData) {
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        const diff = Math.abs(imageData.data[i] - lastFrameData.data[i]);
                        totalChange += diff;
                    }
                }
                lastFrameData = ctx.getImageData(0, 0, 40, 30);
                
                // Encode to 8 bits (0-255)
                const activityLevel = Math.min(255, Math.floor(totalChange / 500));
                
                // Update our frequency based on activity
                myFrequency = 500 + activityLevel * 10;
                
                // ğŸ”¥ TRUE 0-DATA: Send ONLY phase signature (~50 bytes total!)
                if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                    const phaseMessage = {
                        type: 'phase',
                        call_id: currentCallId,
                        sender_id: myDeltaId,
                        bits: activityLevel,           // 8 bits: activity level
                        frequency: myFrequency,        // Float: resonance frequency
                        coherence: resonanceCoherence, // Float: sync quality
                        timestamp: Date.now() / 1000
                        // NO tile_data! NO spike_events! TRUE 0-DATA!
                    };
                    
                    webSocket.send(JSON.stringify(phaseMessage));
                }
                
                // Update stats
                const phasePacket = new Î”Packet('videoPhase', {
                    bits: activityLevel,
                    frequency: myFrequency,
                    coherence: resonanceCoherence
                });
                sendPacket(phasePacket);
                
                // Update display - TRUE 0-DATA!
                document.getElementById('bitsPerFrame').textContent = '9 bits (TRUE 0-DATA!)';
                
            }, 33); // ~30fps
        }
        
        // ğŸ”¥ğŸ’€âš¡ 0-DATA Video: Reconstruct from Phase! âš¡ğŸ’€ğŸ”¥
        // ===============================================
        
        function handlePhaseData(data) {
            const bits = data.bits || 0;
            const frequency = data.frequency || 500;
            const coherence = data.coherence || 0;
            
            console.log('ğŸ“¥ Phase received:', bits, 'bits, freq:', frequency.toFixed(1));
            
            // ğŸ”¥ Update peer frequency for synced view!
            peerFrequency = frequency;
            
            // ğŸ”¥ RESONANCE SYNC
            syncToPeerFrequency(frequency);
            resonanceCoherence = Math.max(resonanceCoherence, coherence);
            
            // Update stats display
            document.getElementById('currentPhase').textContent = 
                `${Math.floor(resonanceCoherence * 100)}% sync`;
        }
        
        // ğŸ”¥ Reconstruct video from phase signature
        function reconstructVideoFromPhase(bits) {
            if (!remoteFrameBuffer) {
                remoteFrameBuffer = new Array(remoteFrameWidth * remoteFrameHeight).fill(0.5);
            }
            
            // Decode phase bits
            const changeCount = (bits & 0x07) * 10;        // Lower 3 bits
            const avgDelta = ((bits >> 3) & 0x07) / 7.0;   // Middle 3 bits
            const dirBits = (bits >> 6) & 0x03;            // Upper 2 bits
            const moveRight = (dirBits & 0x01) !== 0;
            const moveDown = (dirBits & 0x02) !== 0;
            
            // Motion vectors
            const dx = moveRight ? 1 : -1;
            const dy = moveDown ? 1 : -1;
            
            // Apply temporal smoothing with motion
            const newBuffer = new Array(remoteFrameBuffer.length);
            
            for (let y = 0; y < remoteFrameHeight; y++) {
                for (let x = 0; x < remoteFrameWidth; x++) {
                    const idx = y * remoteFrameWidth + x;
                    
                    // Motion compensation
                    const srcX = Math.min(Math.max(0, x - dx), remoteFrameWidth - 1);
                    const srcY = Math.min(Math.max(0, y - dy), remoteFrameHeight - 1);
                    const srcIdx = srcY * remoteFrameWidth + srcX;
                    
                    const motionBlend = remoteFrameBuffer[srcIdx];
                    
                    // Phase-based variation
                    const phaseVariation = Math.sin((x + y) * 0.1 + bits * 0.05) * avgDelta * 0.3;
                    
                    // Temporal smoothing
                    let newValue = remoteFrameBuffer[idx] * 0.7 + motionBlend * 0.2 + phaseVariation * 0.1 + 0.5;
                    newBuffer[idx] = Math.max(0, Math.min(1, newValue));
                }
            }
            
            // Add activity hotspots
            if (changeCount > 0) {
                const centerX = moveRight ? remoteFrameWidth * 3 / 4 : remoteFrameWidth / 4;
                const centerY = moveDown ? remoteFrameHeight * 3 / 4 : remoteFrameHeight / 4;
                const radius = Math.min(40, changeCount * 2);
                
                for (let y = Math.max(0, Math.floor(centerY - radius)); y < Math.min(remoteFrameHeight, Math.floor(centerY + radius)); y++) {
                    for (let x = Math.max(0, Math.floor(centerX - radius)); x < Math.min(remoteFrameWidth, Math.floor(centerX + radius)); x++) {
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        if (dist < radius) {
                            const idx = y * remoteFrameWidth + x;
                            const intensity = (1.0 - dist / radius) * avgDelta * 0.5;
                            newBuffer[idx] = Math.min(1.0, newBuffer[idx] + intensity);
                        }
                    }
                }
            }
            
            remoteFrameBuffer = newBuffer;
        }
        
        // ğŸ”¥ Phase-based video reconstruction (fallback - legacy)
        let remoteBuffer = null;
        
        function reconstructRemoteVideo(bits, data) {
            const remoteVideo = document.getElementById('remoteVideo');
            
            // Create canvas for reconstruction if needed
            if (!remoteCanvas) {
                remoteCanvas = document.createElement('canvas');
                remoteCanvas.width = 160;
                remoteCanvas.height = 120;
                remoteCtx = remoteCanvas.getContext('2d');
                remoteBuffer = remoteCtx.createImageData(160, 120);
                
                // Initialize with gray
                for (let i = 0; i < remoteBuffer.data.length; i += 4) {
                    remoteBuffer.data[i] = 80;     // R
                    remoteBuffer.data[i + 1] = 80; // G
                    remoteBuffer.data[i + 2] = 100; // B
                    remoteBuffer.data[i + 3] = 255; // A
                }
            }
            
            // Decode phase bits
            const changeCount = (bits & 0x07) * 10;
            const avgDelta = ((bits >> 3) & 0x07) / 70.0;
            const dirBits = (bits >> 6) & 0x03;
            const moveRight = (dirBits & 0x01) !== 0;
            const moveDown = (dirBits & 0x02) !== 0;
            
            // Apply phase-based changes
            const width = 160;
            const height = 120;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    
                    // Motion compensation
                    const dx = moveRight ? 1 : -1;
                    const dy = moveDown ? 1 : -1;
                    const srcX = Math.min(Math.max(0, x - dx), width - 1);
                    const srcY = Math.min(Math.max(0, y - dy), height - 1);
                    const srcIdx = (srcY * width + srcX) * 4;
                    
                    // Temporal blend with motion
                    const prevR = remoteBuffer.data[srcIdx];
                    const prevG = remoteBuffer.data[srcIdx + 1];
                    const prevB = remoteBuffer.data[srcIdx + 2];
                    
                    // Phase-based variation
                    const phaseVar = Math.sin((x + y) * 0.1 + bits * 0.05) * avgDelta * 30;
                    
                    // Update with temporal smoothing
                    remoteBuffer.data[idx] = Math.min(255, Math.max(0, prevR * 0.9 + phaseVar + 50));
                    remoteBuffer.data[idx + 1] = Math.min(255, Math.max(0, prevG * 0.9 + phaseVar + 80));
                    remoteBuffer.data[idx + 2] = Math.min(255, Math.max(0, prevB * 0.9 + phaseVar + 100));
                }
            }
            
            // Add activity hotspot
            if (changeCount > 0) {
                const centerX = moveRight ? width * 3 / 4 : width / 4;
                const centerY = moveDown ? height * 3 / 4 : height / 4;
                const radius = Math.min(30, changeCount);
                
                for (let y = Math.max(0, centerY - radius); y < Math.min(height, centerY + radius); y++) {
                    for (let x = Math.max(0, centerX - radius); x < Math.min(width, centerX + radius); x++) {
                        const dist = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                        if (dist < radius) {
                            const idx = (y * width + x) * 4;
                            const intensity = (1.0 - dist / radius) * avgDelta * 50;
                            remoteBuffer.data[idx] = Math.min(255, remoteBuffer.data[idx] + intensity);
                            remoteBuffer.data[idx + 1] = Math.min(255, remoteBuffer.data[idx + 1] + intensity * 0.8);
                            remoteBuffer.data[idx + 2] = Math.min(255, remoteBuffer.data[idx + 2] + intensity * 1.2);
                        }
                    }
                }
            }
            
            // Draw to canvas
            remoteCtx.putImageData(remoteBuffer, 0, 0);
            
            // Display on remote video element
            if (!remoteVideo.srcObject) {
                const stream = remoteCanvas.captureStream(30);
                remoteVideo.srcObject = stream;
            }
            
            lastRemotePhase = bits;
        }
        
        // ========================================
        // Call Controls
        // ========================================
        
        async function endCall() {
            const endPacket = new Î”Packet('call_end', {
                call_id: currentCallId,
                duration: callStartTime ? (Date.now() - callStartTime) / 1000 : 0
            });
            
            if (currentCallId) {
                try {
                    await fetch(`${SERVER_URL}/v1/call/end`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            call_id: currentCallId,
                            user_id: myDeltaId
                        })
                    });
                    sendPacket(endPacket);
                } catch (error) {
                    console.error('End call failed:', error);
                }
            }
            
            // Stop video
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Stop timer
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
            
            document.getElementById('videoContainer').classList.remove('active');
            resetCallUI();
        }
        
        function cancelCall() {
            endCall();
        }
        
        function resetCallUI() {
            currentCallId = null;
            document.getElementById('callInput').style.display = 'block';
            document.getElementById('callInput').innerHTML = `
                <h3>ğŸ“ ×”×ª×§×©×¨ ×“×¨×š Î”Network</h3>
                <div class="input-group">
                    <input type="text" id="targetDeltaId" placeholder="×”×›× ×¡ Î”ID ×©×œ ××™ ×©×¨×•×¦×™× ×œ×”×ª×§×©×¨...">
                    <button class="btn btn-call" onclick="startCall()">
                        ğŸ“ Î”Call
                    </button>
                </div>
            `;
            document.getElementById('incomingCall').style.display = 'none';
        }
        
        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('muteBtn').textContent = audioTrack.enabled ? 'ğŸ¤' : 'ğŸ”‡';
            }
        }
        
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('videoBtn').textContent = videoTrack.enabled ? 'ğŸ“¹' : 'ğŸ“·';
            }
        }
        
        // ========================================
        // Packet Logging
        // ========================================
        
        function logPacket(direction, context, data) {
            const entries = document.getElementById('packetEntries');
            const entry = document.createElement('div');
            entry.className = `packet-entry ${direction}`;
            
            const time = new Date().toLocaleTimeString('he-IL');
            const arrow = direction === 'tx' ? 'â†’' : 'â†';
            
            entry.textContent = `${time} ${arrow} ${context}`;
            entries.insertBefore(entry, entries.firstChild);
            
            // Keep only last 20 entries
            while (entries.children.length > 20) {
                entries.removeChild(entries.lastChild);
            }
        }
        
        // ========================================
        // Status Update
        // ========================================
        
        function updateStatus(text, type) {
            const el = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            statusText.textContent = text;
            el.className = `connection-status ${type}`;
        }
        
        function hideIncomingCall() {
            document.getElementById('incomingCall').style.display = 'none';
        }
        
        function showCallActive() {
            document.getElementById('videoContainer').classList.add('active');
            document.getElementById('callInput').style.display = 'none';
            callStartTime = Date.now();
            callTimer = setInterval(updateCallDuration, 1000);
        }
        
        // ========================================
        // Initialize - P2P ONLY! NO SERVER NEEDED!
        // ========================================
        
        initDeltaId();
        
        // ğŸ”¥ P2P Mode - No WebSocket needed for basic calls!
        // WebSocket is optional - only for our own server
        const isLocalServer = window.location.hostname === 'localhost' || 
                             window.location.hostname === '192.168.1.115' ||
                             window.location.hostname.includes('deltaworlds');
        
        if (isLocalServer) {
            console.log('ğŸ  Local server detected - connecting WebSocket...');
            connectWebSocket();
        } else {
            console.log('ğŸŒ Public mode - P2P only (no WebSocket needed!)');
            updateStatus('××—×•×‘×¨ ×œ×¨×©×ª Î” (P2P)', 'connected');
        }
        
        // Subscribe to FieldBus events
        fieldBus.subscribe('all', (packet) => {
            console.log('FieldBus:', packet);
        });
    </script>
</body>
</html>
